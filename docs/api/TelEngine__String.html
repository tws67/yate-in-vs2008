<HTML>
<HEAD>
<TITLE>class String</TITLE>

<META NAME="Generator" CONTENT="KDOC ">
</HEAD>
<BODY bgcolor="#ffffff" text="#000000" link="#0000ff" vlink="#000099" alink= "#ffffff">
<TABLE WIDTH="100%" BORDER="0">
<TR>
<TD>
	<TABLE BORDER="0">
		<TR><TD valign="top" align="left" cellspacing="10">
		<h1>class String</h1>
		</TD>
		<TD valign="top" align="right" colspan="1">A C-style string handling class. <small><A HREF="#longdesc">More...</A></small></TD></TR>
	</TABLE>
	<HR>
	<TABLE BORDER="0">
		<TR><TH>Full name</TH><TD><code><A HREF="TelEngine.html">TelEngine</A>::String</code></TD></TR>
<TR><TH>Definition</TH><TD><code>#include &lt;<A HREF="yateclass_h.html">yateclass.h</A>&gt;</code></TD></TR>
<TR><TH>Inherits</TH><TD><A HREF="TelEngine__GenObject.html">TelEngine::GenObject</A> <small>[public ]</small></TD></TR>
<TR><TH>Inherited by</TH><TD><A HREF="TelEngine__CallInfo.html">CallInfo</A>, <A HREF="TelEngine__ClientAccountList.html">ClientAccountList</A>, <A HREF="TelEngine__ClientSound.html">ClientSound</A>, <A HREF="TelEngine__Configuration.html">Configuration</A>, <A HREF="TelEngine__DataFormat.html">DataFormat</A>, <A HREF="TelEngine__ISDNQ931IE.html">ISDNQ931IE</A>, <A HREF="TelEngine__JGSentStanza.html">JGSentStanza</A>, <A HREF="TelEngine__JabberID.html">JabberID</A>, <A HREF="TelEngine__Message.html">Message</A>, <i><A HREF="TelEngine__MessageHandler.html">MessageHandler</A></i>, <A HREF="TelEngine__MessageRelay.html">MessageRelay</A>, <A HREF="TelEngine__MimeAuthLine.html">MimeAuthLine</A>, <A HREF="TelEngine__MimeHeaderLine.html">MimeHeaderLine</A>, <A HREF="TelEngine__NamedList.html">NamedList</A>, <A HREF="TelEngine__NamedPointer.html">NamedPointer</A>, <A HREF="TelEngine__NamedString.html">NamedString</A>, <A HREF="TelEngine__Regexp.html">Regexp</A>, <A HREF="TelEngine__SIPDialog.html">SIPDialog</A>, <A HREF="TelEngine__SignallingCircuitEvent.html">SignallingCircuitEvent</A>, <A HREF="TelEngine__SignallingCircuitRange.html">SignallingCircuitRange</A>, <i><A HREF="TelEngine__UIFactory.html">UIFactory</A></i>, <A HREF="TelEngine__UIWidget.html">UIWidget</A>, <A HREF="TelEngine__URI.html">URI</A></TD></TR>
<TR><TH><A HREF="full-list-TelEngine__String.html">List of all Methods</A></TH></TR>
	</TABLE>
	</TD>
<TD align="right"><TABLE BORDER="0"><TR><TD><small><A HREF="index-long.html">Annotated List</A></small></TD></TR>
<TR><TD><small><A HREF="header-list.html">Files</A></small></TD></TR>
<TR><TD><small><A HREF="all-globals.html">Globals</A></small></TD></TR>
<TR><TD><small><A HREF="hier.html">Hierarchy</A></small></TD></TR>
<TR><TD><small><A HREF="index.html">Index</A></small></TD></TR>
</TABLE></TD></TR></TABLE>
<h4>Public Methods</h4><ul><LI>&nbsp;<b><A HREF="#ref1">String</A></b> () 
</LI>
<LI>&nbsp;<b><A HREF="#ref2">String</A></b> (const char* value, int len = -1) 
</LI>
<LI>&nbsp;<b><A HREF="#ref3">String</A></b> (char value, unsigned int repeat = 1) 
</LI>
<LI>&nbsp;<b><A HREF="#ref4">String</A></b> (int value) 
</LI>
<LI>&nbsp;<b><A HREF="#ref5">String</A></b> (unsigned int value) 
</LI>
<LI>&nbsp;<b><A HREF="#ref6">String</A></b> (bool value) 
</LI>
<LI>&nbsp;<b><A HREF="#ref7">String</A></b> (const String& value) 
</LI>
<LI>&nbsp;<b><A HREF="#ref8">String</A></b> (const String* value) 
</LI>
<LI>virtual  &nbsp;<b><A HREF="#ref9">~String</A></b> () 
</LI>
<LI>virtual  void* &nbsp;<b><A HREF="#ref10">getObject</A></b> (const String& name)  const
</LI>
<LI>inline const char* &nbsp;<b><A HREF="#ref13">c_str</A></b> ()  const
</LI>
<LI>inline const char* &nbsp;<b><A HREF="#ref14">safe</A></b> ()  const
</LI>
<LI>inline unsigned int &nbsp;<b><A HREF="#ref15">length</A></b> ()  const
</LI>
<LI>inline bool &nbsp;<b><A HREF="#ref16">null</A></b> ()  const
</LI>
<LI>inline int &nbsp;<b><A HREF="#ref18">lenUtf8</A></b> (unsigned int maxSeq = 4, bool overlong = false)  const
</LI>
<LI>int &nbsp;<b><A HREF="#ref19">fixUtf8</A></b> (const char* replace = 0, unsigned int maxSeq = 4, bool overlong = false) 
</LI>
<LI>unsigned int &nbsp;<b><A HREF="#ref20">hash</A></b> ()  const
</LI>
<LI>void &nbsp;<b><A HREF="#ref22">clear</A></b> () 
</LI>
<LI>char &nbsp;<b><A HREF="#ref23">at</A></b> (int index)  const
</LI>
<LI>String &nbsp;<b><A HREF="#ref24">substr</A></b> (int offs, int len = -1)  const
</LI>
<LI>String& &nbsp;<b><A HREF="#ref25">trimBlanks</A></b> () 
</LI>
<LI>virtual  const String& &nbsp;<b><A HREF="#ref26">toString</A></b> ()  const
</LI>
<LI>int &nbsp;<b><A HREF="#ref27">toInteger</A></b> (int defvalue = 0, int base = 0)  const
</LI>
<LI>int &nbsp;<b><A HREF="#ref28">toInteger</A></b> (const TokenDict* tokens, int defvalue = 0, int base = 0)  const
</LI>
<LI>double &nbsp;<b><A HREF="#ref29">toDouble</A></b> (double defvalue = 0.0)  const
</LI>
<LI>bool &nbsp;<b><A HREF="#ref30">toBoolean</A></b> (bool defvalue = false)  const
</LI>
<LI>bool &nbsp;<b><A HREF="#ref31">isBoolean</A></b> ()  const
</LI>
<LI>String& &nbsp;<b><A HREF="#ref32">toUpper</A></b> () 
</LI>
<LI>String& &nbsp;<b><A HREF="#ref33">toLower</A></b> () 
</LI>
<LI>inline char &nbsp;<b><A HREF="#ref34">operator[]</A></b> (int index)  const
</LI>
<LI>inline &nbsp;<b><A HREF="#ref35">operator const char*</A></b> ()  const
</LI>
<LI>String& &nbsp;<b><A HREF="#ref36">assign</A></b> (const char* value, int len = -1) 
</LI>
<LI>String& &nbsp;<b><A HREF="#ref37">assign</A></b> (char value, unsigned int repeat = 1) 
</LI>
<LI>String& &nbsp;<b><A HREF="#ref38">hexify</A></b> (void* data, unsigned int len, char sep = 0, bool upCase = false) 
</LI>
<LI>inline String& &nbsp;<b><A HREF="#ref39">operator=</A></b> (const String& value) 
</LI>
<LI>inline String& &nbsp;<b><A HREF="#ref40">operator=</A></b> (const String* value) 
</LI>
<LI>String& &nbsp;<b><A HREF="#ref41">operator=</A></b> (const char* value) 
</LI>
<LI>String& &nbsp;<b><A HREF="#ref42">operator=</A></b> (char value) 
</LI>
<LI>String& &nbsp;<b><A HREF="#ref43">operator=</A></b> (int value) 
</LI>
<LI>String& &nbsp;<b><A HREF="#ref44">operator=</A></b> (unsigned int value) 
</LI>
<LI>inline String& &nbsp;<b><A HREF="#ref45">operator=</A></b> (bool value) 
</LI>
<LI>String& &nbsp;<b><A HREF="#ref46">operator+=</A></b> (const char* value) 
</LI>
<LI>String& &nbsp;<b><A HREF="#ref47">operator+=</A></b> (char value) 
</LI>
<LI>String& &nbsp;<b><A HREF="#ref48">operator+=</A></b> (int value) 
</LI>
<LI>String& &nbsp;<b><A HREF="#ref49">operator+=</A></b> (unsigned int value) 
</LI>
<LI>inline String& &nbsp;<b><A HREF="#ref50">operator+=</A></b> (bool value) 
</LI>
<LI>bool &nbsp;<b><A HREF="#ref51">operator==</A></b> (const char* value)  const
</LI>
<LI>bool &nbsp;<b><A HREF="#ref52">operator!=</A></b> (const char* value)  const
</LI>
<LI>bool &nbsp;<b><A HREF="#ref53">operator==</A></b> (const String& value)  const
</LI>
<LI>bool &nbsp;<b><A HREF="#ref54">operator!=</A></b> (const String& value)  const
</LI>
<LI>bool &nbsp;<b><A HREF="#ref55">operator&=</A></b> (const char* value)  const
</LI>
<LI>bool &nbsp;<b><A HREF="#ref56">operator|=</A></b> (const char* value)  const
</LI>
<LI>inline String& &nbsp;<b><A HREF="#ref57">operator<<</A></b> (const char* value) 
</LI>
<LI>inline String& &nbsp;<b><A HREF="#ref58">operator<<</A></b> (char value) 
</LI>
<LI>inline String& &nbsp;<b><A HREF="#ref59">operator<<</A></b> (int value) 
</LI>
<LI>inline String& &nbsp;<b><A HREF="#ref60">operator<<</A></b> (unsigned int value) 
</LI>
<LI>inline String& &nbsp;<b><A HREF="#ref61">operator<<</A></b> (bool value) 
</LI>
<LI>String& &nbsp;<b><A HREF="#ref62">operator>></A></b> (const char* skip) 
</LI>
<LI>String& &nbsp;<b><A HREF="#ref63">operator>></A></b> (char& store) 
</LI>
<LI>String& &nbsp;<b><A HREF="#ref64">operator>></A></b> (int& store) 
</LI>
<LI>String& &nbsp;<b><A HREF="#ref65">operator>></A></b> (unsigned int& store) 
</LI>
<LI>String& &nbsp;<b><A HREF="#ref66">operator>></A></b> (bool& store) 
</LI>
<LI>String& &nbsp;<b><A HREF="#ref67">append</A></b> (const char* value, const char* separator = 0, bool force = false) 
</LI>
<LI>String& &nbsp;<b><A HREF="#ref68">append</A></b> (const ObjList* list, const char* separator = 0, bool force = false) 
</LI>
<LI>inline String& &nbsp;<b><A HREF="#ref69">append</A></b> (const ObjList& list, const char* separator = 0, bool force = false) 
</LI>
<LI>String& &nbsp;<b><A HREF="#ref70">append</A></b> (double value, unsigned int decimals = 3) 
</LI>
<LI>int &nbsp;<b><A HREF="#ref71">find</A></b> (char what, unsigned int offs = 0)  const
</LI>
<LI>int &nbsp;<b><A HREF="#ref72">find</A></b> (const char* what, unsigned int offs = 0)  const
</LI>
<LI>int &nbsp;<b><A HREF="#ref73">rfind</A></b> (char what)  const
</LI>
<LI>bool &nbsp;<b><A HREF="#ref74">startsWith</A></b> (const char* what, bool wordBreak = false, bool caseInsensitive = false)  const
</LI>
<LI>bool &nbsp;<b><A HREF="#ref75">endsWith</A></b> (const char* what, bool wordBreak = false, bool caseInsensitive = false)  const
</LI>
<LI>bool &nbsp;<b><A HREF="#ref76">startSkip</A></b> (const char* what, bool wordBreak = true, bool caseInsensitive = false) 
</LI>
<LI>virtual  bool &nbsp;<b><A HREF="#ref77">matches</A></b> (const String& value)  const
</LI>
<LI>bool &nbsp;<b><A HREF="#ref78">matches</A></b> (Regexp& rexp) 
</LI>
<LI>int &nbsp;<b><A HREF="#ref79">matchOffset</A></b> (int index = 0)  const
</LI>
<LI>int &nbsp;<b><A HREF="#ref80">matchLength</A></b> (int index = 0)  const
</LI>
<LI>inline String &nbsp;<b><A HREF="#ref81">matchString</A></b> (int index = 0)  const
</LI>
<LI>String &nbsp;<b><A HREF="#ref82">replaceMatches</A></b> (const String& templ)  const
</LI>
<LI>int &nbsp;<b><A HREF="#ref83">matchCount</A></b> ()  const
</LI>
<LI>ObjList* &nbsp;<b><A HREF="#ref84">split</A></b> (char separator, bool emptyOK = true)  const
</LI>
<LI>inline String &nbsp;<b><A HREF="#ref86">msgEscape</A></b> (char extraEsc = 0)  const
</LI>
<LI>inline String &nbsp;<b><A HREF="#ref88">msgUnescape</A></b> (int* errptr = 0, char extraEsc = 0)  const
</LI>
<LI>inline String &nbsp;<b><A HREF="#ref90">sqlEscape</A></b> (char extraEsc = 0)  const
</LI>
<LI>inline String &nbsp;<b><A HREF="#ref92">uriEscape</A></b> (char extraEsc = 0)  const
</LI>
<LI>inline String &nbsp;<b><A HREF="#ref94">uriUnescape</A></b> (int* errptr = 0)  const
</LI>
</ul><h4>Public Static Methods</h4><ul><LI>static  const String& &nbsp;<b><A HREF="#ref11">empty</A></b> () 
</LI>
<LI>static inline  const char* &nbsp;<b><A HREF="#ref12">boolText</A></b> (bool value) 
</LI>
<LI>static  int &nbsp;<b><A HREF="#ref17">lenUtf8</A></b> (const char* value, unsigned int maxSeq = 4, bool overlong = false) 
</LI>
<LI>static  unsigned int &nbsp;<b><A HREF="#ref21">hash</A></b> (const char* value) 
</LI>
<LI>static  String &nbsp;<b><A HREF="#ref85">msgEscape</A></b> (const char* str, char extraEsc = 0) 
</LI>
<LI>static  String &nbsp;<b><A HREF="#ref87">msgUnescape</A></b> (const char* str, int* errptr = 0, char extraEsc = 0) 
</LI>
<LI>static  String &nbsp;<b><A HREF="#ref89">sqlEscape</A></b> (const char* str, char extraEsc = 0) 
</LI>
<LI>static  String &nbsp;<b><A HREF="#ref91">uriEscape</A></b> (const char* str, char extraEsc = 0) 
</LI>
<LI>static  String &nbsp;<b><A HREF="#ref93">uriUnescape</A></b> (const char* str, int* errptr = 0) 
</LI>
</ul><h4>Protected Methods</h4><ul><LI>virtual  void &nbsp;<b><A HREF="#ref95">changed</A></b> () 
</LI>
</ul><HR><H2><A NAME="longdesc">Detailed Description</A></H2><p>
 A simple string handling class for C style (one byte) strings.
 For simplicity and read speed no copy-on-write is performed.
 Strings have hash capabilities and comparations are using the hash
 for fast inequality check.
</p>
<A NAME="String"></A><A NAME="ref1"></A><table width="100%"><tr bgcolor="#eeeeee"><td>&nbsp;<strong>String</strong> ()
<br></td><td align="right"><h3><strong>String</strong></h3></td></tr></table><p></p><p>
 Creates a new, empty string.
     </p>
<A NAME="String"></A><A NAME="ref2"></A><table width="100%"><tr bgcolor="#eeeeee"><td>&nbsp;<strong>String</strong> (const char* value, int len = -1)
<br></td><td align="right"><h3><strong>String</strong></h3></td></tr></table><p></p><p>
 Creates a new initialized string.
</p>
<p><b>Parameters</b>:<TABLE BORDER="0" CELLPADDING="5">
<TR><TD align="left" valign="top"><i>value</i></TD><TD align="left" valign="top">Initial value of the string
</TD></TR>
<TR><TD align="left" valign="top"><i>len</i></TD><TD align="left" valign="top">Length of the data to copy, -1 for full string
     </TD></TR>
</TABLE></P>
<A NAME="String"></A><A NAME="ref3"></A><table width="100%"><tr bgcolor="#eeeeee"><td>&nbsp;<strong>String</strong> (char value, unsigned int repeat = 1)
<br></td><td align="right"><h3><strong>String</strong></h3></td></tr></table><p></p><p>
 Creates a new initialized string.
</p>
<p><b>Parameters</b>:<TABLE BORDER="0" CELLPADDING="5">
<TR><TD align="left" valign="top"><i>value</i></TD><TD align="left" valign="top">Character to fill the string
</TD></TR>
<TR><TD align="left" valign="top"><i>repeat</i></TD><TD align="left" valign="top">How many copies of the character to use
     </TD></TR>
</TABLE></P>
<A NAME="String"></A><A NAME="ref4"></A><table width="100%"><tr bgcolor="#eeeeee"><td>&nbsp;<strong>String</strong> (int value)
<br></td><td align="right"><h3><strong>String</strong></h3></td></tr></table><p></p><p>
 Creates a new initialized string from an integer.
</p>
<p><b>Parameters</b>:<TABLE BORDER="0" CELLPADDING="5">
<TR><TD align="left" valign="top"><i>value</i></TD><TD align="left" valign="top">Value to convert to string
     </TD></TR>
</TABLE></P>
<A NAME="String"></A><A NAME="ref5"></A><table width="100%"><tr bgcolor="#eeeeee"><td>&nbsp;<strong>String</strong> (unsigned int value)
<br></td><td align="right"><h3><strong>String</strong></h3></td></tr></table><p></p><p>
 Creates a new initialized string from an unsigned int.
</p>
<p><b>Parameters</b>:<TABLE BORDER="0" CELLPADDING="5">
<TR><TD align="left" valign="top"><i>value</i></TD><TD align="left" valign="top">Value to convert to string
     </TD></TR>
</TABLE></P>
<A NAME="String"></A><A NAME="ref6"></A><table width="100%"><tr bgcolor="#eeeeee"><td>&nbsp;<strong>String</strong> (bool value)
<br></td><td align="right"><h3><strong>String</strong></h3></td></tr></table><p></p><p>
 Creates a new initialized string from a boolean.
</p>
<p><b>Parameters</b>:<TABLE BORDER="0" CELLPADDING="5">
<TR><TD align="left" valign="top"><i>value</i></TD><TD align="left" valign="top">Value to convert to string
     </TD></TR>
</TABLE></P>
<A NAME="String"></A><A NAME="ref7"></A><table width="100%"><tr bgcolor="#eeeeee"><td>&nbsp;<strong>String</strong> (const String& value)
<br></td><td align="right"><h3><strong>String</strong></h3></td></tr></table><p></p><p>
 Copy constructor.
</p>
<p><b>Parameters</b>:<TABLE BORDER="0" CELLPADDING="5">
<TR><TD align="left" valign="top"><i>value</i></TD><TD align="left" valign="top">Initial value of the string
     </TD></TR>
</TABLE></P>
<A NAME="String"></A><A NAME="ref8"></A><table width="100%"><tr bgcolor="#eeeeee"><td>&nbsp;<strong>String</strong> (const String* value)
<br></td><td align="right"><h3><strong>String</strong></h3></td></tr></table><p></p><p>
 Constructor from String pointer.
</p>
<p><b>Parameters</b>:<TABLE BORDER="0" CELLPADDING="5">
<TR><TD align="left" valign="top"><i>value</i></TD><TD align="left" valign="top">Initial value of the string
     </TD></TR>
</TABLE></P>
<A NAME="~String"></A><A NAME="ref9"></A><table width="100%"><tr bgcolor="#eeeeee"><td> &nbsp;<strong>~String</strong> ()
<br></td><td align="right"><h3><strong>~String</strong></h3></td></tr></table><p> <small>[virtual]</small></p><p>
 Destroys the string, disposes the memory.
     </p>
<A NAME="getObject"></A><A NAME="ref10"></A><table width="100%"><tr bgcolor="#eeeeee"><td> void* &nbsp;<strong>getObject</strong> (const String& name)
<br></td><td align="right"><h3><strong>getObject</strong></h3></td></tr></table><p> <small>[const virtual]</small></p><p>
 Get a pointer to a derived class given that class name
</p>
<p><b>Parameters</b>:<TABLE BORDER="0" CELLPADDING="5">
<TR><TD align="left" valign="top"><i>name</i></TD><TD align="left" valign="top">Name of the class we are asking for
</TD></TR>
</TABLE></P>
<p><b>Returns</b>: Pointer to the requested class or NULL if this object doesn't implement it
     </p>
<p>Reimplemented from <A HREF="TelEngine__GenObject.html#getObject">GenObject</A>.</p>
<A NAME="empty"></A><A NAME="ref11"></A><table width="100%"><tr bgcolor="#eeeeee"><td> const String& &nbsp;<strong>empty</strong> ()
<br></td><td align="right"><h3><strong>empty</strong></h3></td></tr></table><p> <small>[static]</small></p><p>
 A static null String
     </p>
<A NAME="boolText"></A><A NAME="ref12"></A><table width="100%"><tr bgcolor="#eeeeee"><td>inline  const char* &nbsp;<strong>boolText</strong> (bool value)
<br></td><td align="right"><h3><strong>boolText</strong></h3></td></tr></table><p> <small>[static]</small></p><p>
 A standard text representation of boolean values
</p>
<p><b>Parameters</b>:<TABLE BORDER="0" CELLPADDING="5">
<TR><TD align="left" valign="top"><i>value</i></TD><TD align="left" valign="top">Boolean value to convert
</TD></TR>
</TABLE></P>
<p><b>Returns</b>: Pointer to a text representation of the value
     </p>
<A NAME="c_str"></A><A NAME="ref13"></A><table width="100%"><tr bgcolor="#eeeeee"><td>inline const char* &nbsp;<strong>c_str</strong> ()
<br></td><td align="right"><h3><strong>c_str</strong></h3></td></tr></table><p> <small>[const]</small></p><p>
 Get the value of the stored string.
</p>
<p><b>Returns</b>: The stored C string which may be NULL.
     </p>
<A NAME="safe"></A><A NAME="ref14"></A><table width="100%"><tr bgcolor="#eeeeee"><td>inline const char* &nbsp;<strong>safe</strong> ()
<br></td><td align="right"><h3><strong>safe</strong></h3></td></tr></table><p> <small>[const]</small></p><p>
 Get a valid non-NULL C string.
</p>
<p><b>Returns</b>: The stored C string or a static "".
     </p>
<A NAME="length"></A><A NAME="ref15"></A><table width="100%"><tr bgcolor="#eeeeee"><td>inline unsigned int &nbsp;<strong>length</strong> ()
<br></td><td align="right"><h3><strong>length</strong></h3></td></tr></table><p> <small>[const]</small></p><p>
 Get the length of the stored string.
</p>
<p><b>Returns</b>: The length of the stored string, zero for NULL.
     </p>
<A NAME="null"></A><A NAME="ref16"></A><table width="100%"><tr bgcolor="#eeeeee"><td>inline bool &nbsp;<strong>null</strong> ()
<br></td><td align="right"><h3><strong>null</strong></h3></td></tr></table><p> <small>[const]</small></p><p>
 Checks if the string holds a NULL pointer.
</p>
<p><b>Returns</b>: True if the string holds NULL, false otherwise.
     </p>
<A NAME="lenUtf8"></A><A NAME="ref17"></A><table width="100%"><tr bgcolor="#eeeeee"><td> int &nbsp;<strong>lenUtf8</strong> (const char* value, unsigned int maxSeq = 4, bool overlong = false)
<br></td><td align="right"><h3><strong>lenUtf8</strong></h3></td></tr></table><p> <small>[static]</small></p><p>
 Get the number of characters in a string assuming UTF-8 encoding
</p>
<p><b>Parameters</b>:<TABLE BORDER="0" CELLPADDING="5">
<TR><TD align="left" valign="top"><i>value</i></TD><TD align="left" valign="top">C string to compute Unicode length
</TD></TR>
<TR><TD align="left" valign="top"><i>maxSeq</i></TD><TD align="left" valign="top">Maximum accepted UTF-8 sequence length
</TD></TR>
<TR><TD align="left" valign="top"><i>overlong</i></TD><TD align="left" valign="top">Accept overlong UTF-8 sequences (dangerous!)
</TD></TR>
</TABLE></P>
<p><b>Returns</b>: Count of Unicode characters, -1 if not valid UTF-8
     </p>
<A NAME="lenUtf8"></A><A NAME="ref18"></A><table width="100%"><tr bgcolor="#eeeeee"><td>inline int &nbsp;<strong>lenUtf8</strong> (unsigned int maxSeq = 4, bool overlong = false)
<br></td><td align="right"><h3><strong>lenUtf8</strong></h3></td></tr></table><p> <small>[const]</small></p><p>
 Get the number of characters in the string assuming UTF-8 encoding
</p>
<p><b>Parameters</b>:<TABLE BORDER="0" CELLPADDING="5">
<TR><TD align="left" valign="top"><i>maxSeq</i></TD><TD align="left" valign="top">Maximum accepted UTF-8 sequence length
</TD></TR>
<TR><TD align="left" valign="top"><i>overlong</i></TD><TD align="left" valign="top">Accept overlong UTF-8 sequences (dangerous!)
</TD></TR>
</TABLE></P>
<p><b>Returns</b>: Count of Unicode characters, -1 if not valid UTF-8
     </p>
<A NAME="fixUtf8"></A><A NAME="ref19"></A><table width="100%"><tr bgcolor="#eeeeee"><td>int &nbsp;<strong>fixUtf8</strong> (const char* replace = 0, unsigned int maxSeq = 4, bool overlong = false)
<br></td><td align="right"><h3><strong>fixUtf8</strong></h3></td></tr></table><p></p><p>
 Fix an UTF-8 encoded string by replacing invalid sequences
</p>
<p><b>Parameters</b>:<TABLE BORDER="0" CELLPADDING="5">
<TR><TD align="left" valign="top"><i>replace</i></TD><TD align="left" valign="top">String to replace invalid sequences, use U+FFFD if null
</TD></TR>
<TR><TD align="left" valign="top"><i>maxSeq</i></TD><TD align="left" valign="top">Maximum accepted UTF-8 sequence length
</TD></TR>
<TR><TD align="left" valign="top"><i>overlong</i></TD><TD align="left" valign="top">Accept overlong UTF-8 sequences (dangerous!)
</TD></TR>
</TABLE></P>
<p><b>Returns</b>: Count of invalid UTF-8 sequences that were replaced
     </p>
<A NAME="hash"></A><A NAME="ref20"></A><table width="100%"><tr bgcolor="#eeeeee"><td>unsigned int &nbsp;<strong>hash</strong> ()
<br></td><td align="right"><h3><strong>hash</strong></h3></td></tr></table><p> <small>[const]</small></p><p>
 Get the hash of the contained string.
</p>
<p><b>Returns</b>: The hash of the string.
     </p>
<A NAME="hash"></A><A NAME="ref21"></A><table width="100%"><tr bgcolor="#eeeeee"><td> unsigned int &nbsp;<strong>hash</strong> (const char* value)
<br></td><td align="right"><h3><strong>hash</strong></h3></td></tr></table><p> <small>[static]</small></p><p>
 Get the hash of an arbitrary string.
</p>
<p><b>Parameters</b>:<TABLE BORDER="0" CELLPADDING="5">
<TR><TD align="left" valign="top"><i>value</i></TD><TD align="left" valign="top">C string to hash
</TD></TR>
</TABLE></P>
<p><b>Returns</b>: The hash of the string.
     </p>
<A NAME="clear"></A><A NAME="ref22"></A><table width="100%"><tr bgcolor="#eeeeee"><td>void &nbsp;<strong>clear</strong> ()
<br></td><td align="right"><h3><strong>clear</strong></h3></td></tr></table><p></p><p>
 Clear the string and free the memory
     </p>
<A NAME="at"></A><A NAME="ref23"></A><table width="100%"><tr bgcolor="#eeeeee"><td>char &nbsp;<strong>at</strong> (int index)
<br></td><td align="right"><h3><strong>at</strong></h3></td></tr></table><p> <small>[const]</small></p><p>
 Extract the caracter at a given index
</p>
<p><b>Parameters</b>:<TABLE BORDER="0" CELLPADDING="5">
<TR><TD align="left" valign="top"><i>index</i></TD><TD align="left" valign="top">Index of character in string
</TD></TR>
</TABLE></P>
<p><b>Returns</b>: Character at given index or 0 if out of range
     </p>
<A NAME="substr"></A><A NAME="ref24"></A><table width="100%"><tr bgcolor="#eeeeee"><td>String &nbsp;<strong>substr</strong> (int offs, int len = -1)
<br></td><td align="right"><h3><strong>substr</strong></h3></td></tr></table><p> <small>[const]</small></p><p>
 Substring extraction
</p>
<p><b>Parameters</b>:<TABLE BORDER="0" CELLPADDING="5">
<TR><TD align="left" valign="top"><i>offs</i></TD><TD align="left" valign="top">Offset of the substring, negative to count from end
</TD></TR>
<TR><TD align="left" valign="top"><i>len</i></TD><TD align="left" valign="top">Length of the substring, -1 for everything possible
</TD></TR>
</TABLE></P>
<p><b>Returns</b>: A copy of the requested substring
     </p>
<A NAME="trimBlanks"></A><A NAME="ref25"></A><table width="100%"><tr bgcolor="#eeeeee"><td>String& &nbsp;<strong>trimBlanks</strong> ()
<br></td><td align="right"><h3><strong>trimBlanks</strong></h3></td></tr></table><p></p><p>
 Strip off leading and trailing blank characters
     </p>
<A NAME="toString"></A><A NAME="ref26"></A><table width="100%"><tr bgcolor="#eeeeee"><td> const String& &nbsp;<strong>toString</strong> ()
<br></td><td align="right"><h3><strong>toString</strong></h3></td></tr></table><p> <small>[const virtual]</small></p><p>
 Override GenObject's method to return this String
</p>
<p><b>Returns</b>: A reference to this String
     </p>
<p>Reimplemented from <A HREF="TelEngine__GenObject.html#toString">GenObject</A>.</p>
<A NAME="toInteger"></A><A NAME="ref27"></A><table width="100%"><tr bgcolor="#eeeeee"><td>int &nbsp;<strong>toInteger</strong> (int defvalue = 0, int base = 0)
<br></td><td align="right"><h3><strong>toInteger</strong></h3></td></tr></table><p> <small>[const]</small></p><p>
 Convert the string to an integer value.
</p>
<p><b>Parameters</b>:<TABLE BORDER="0" CELLPADDING="5">
<TR><TD align="left" valign="top"><i>defvalue</i></TD><TD align="left" valign="top">Default to return if the string is not a number
</TD></TR>
<TR><TD align="left" valign="top"><i>base</i></TD><TD align="left" valign="top">Numeration base, 0 to autodetect
</TD></TR>
</TABLE></P>
<p><b>Returns</b>: The integer interpretation or defvalue.
     </p>
<A NAME="toInteger"></A><A NAME="ref28"></A><table width="100%"><tr bgcolor="#eeeeee"><td>int &nbsp;<strong>toInteger</strong> (const TokenDict* tokens, int defvalue = 0, int base = 0)
<br></td><td align="right"><h3><strong>toInteger</strong></h3></td></tr></table><p> <small>[const]</small></p><p>
 Convert the string to an integer value looking up first a token table.
</p>
<p><b>Parameters</b>:<TABLE BORDER="0" CELLPADDING="5">
<TR><TD align="left" valign="top"><i>tokens</i></TD><TD align="left" valign="top">Pointer to an array of tokens to lookup first
</TD></TR>
<TR><TD align="left" valign="top"><i>defvalue</i></TD><TD align="left" valign="top">Default to return if the string is not a token or number
</TD></TR>
<TR><TD align="left" valign="top"><i>base</i></TD><TD align="left" valign="top">Numeration base, 0 to autodetect
</TD></TR>
</TABLE></P>
<p><b>Returns</b>: The integer interpretation or defvalue.
     </p>
<A NAME="toDouble"></A><A NAME="ref29"></A><table width="100%"><tr bgcolor="#eeeeee"><td>double &nbsp;<strong>toDouble</strong> (double defvalue = 0.0)
<br></td><td align="right"><h3><strong>toDouble</strong></h3></td></tr></table><p> <small>[const]</small></p><p>
 Convert the string to a floating point value.
</p>
<p><b>Parameters</b>:<TABLE BORDER="0" CELLPADDING="5">
<TR><TD align="left" valign="top"><i>defvalue</i></TD><TD align="left" valign="top">Default to return if the string is not a number
</TD></TR>
</TABLE></P>
<p><b>Returns</b>: The floating-point interpretation or defvalue.
     </p>
<A NAME="toBoolean"></A><A NAME="ref30"></A><table width="100%"><tr bgcolor="#eeeeee"><td>bool &nbsp;<strong>toBoolean</strong> (bool defvalue = false)
<br></td><td align="right"><h3><strong>toBoolean</strong></h3></td></tr></table><p> <small>[const]</small></p><p>
 Convert the string to a boolean value.
</p>
<p><b>Parameters</b>:<TABLE BORDER="0" CELLPADDING="5">
<TR><TD align="left" valign="top"><i>defvalue</i></TD><TD align="left" valign="top">Default to return if the string is not a bool
</TD></TR>
</TABLE></P>
<p><b>Returns</b>: The boolean interpretation or defvalue.
     </p>
<A NAME="isBoolean"></A><A NAME="ref31"></A><table width="100%"><tr bgcolor="#eeeeee"><td>bool &nbsp;<strong>isBoolean</strong> ()
<br></td><td align="right"><h3><strong>isBoolean</strong></h3></td></tr></table><p> <small>[const]</small></p><p>
 Check if the string can be converted to a boolean value.
</p>
<p><b>Returns</b>: True if the string is a valid boolean.
     </p>
<A NAME="toUpper"></A><A NAME="ref32"></A><table width="100%"><tr bgcolor="#eeeeee"><td>String& &nbsp;<strong>toUpper</strong> ()
<br></td><td align="right"><h3><strong>toUpper</strong></h3></td></tr></table><p></p><p>
 Turn the string to an all-uppercase string
</p>
<p><b>Returns</b>: A reference to this String
     </p>
<A NAME="toLower"></A><A NAME="ref33"></A><table width="100%"><tr bgcolor="#eeeeee"><td>String& &nbsp;<strong>toLower</strong> ()
<br></td><td align="right"><h3><strong>toLower</strong></h3></td></tr></table><p></p><p>
 Turn the string to an all-lowercase string
</p>
<p><b>Returns</b>: A reference to this String
     </p>
<A NAME="operator[]"></A><A NAME="ref34"></A><table width="100%"><tr bgcolor="#eeeeee"><td>inline char &nbsp;<strong>operator[]</strong> (int index)
<br></td><td align="right"><h3><strong>operator[]</strong></h3></td></tr></table><p> <small>[const]</small></p><p>
 Indexing operator
</p>
<p><b>Parameters</b>:<TABLE BORDER="0" CELLPADDING="5">
<TR><TD align="left" valign="top"><i>index</i></TD><TD align="left" valign="top">Index of character in string
</TD></TR>
</TABLE></P>
<p><b>Returns</b>: Character at given index or 0 if out of range
     </p>
<A NAME="operator%20const%20char*"></A><A NAME="ref35"></A><table width="100%"><tr bgcolor="#eeeeee"><td>inline &nbsp;<strong>operator const char*</strong> ()
<br></td><td align="right"><h3><strong>operator const char*</strong></h3></td></tr></table><p> <small>[const]</small></p><p>
 Conversion to "const char *" operator.
</p>
<p><b>Returns</b>: Pointer to the internally stored string
     </p>
<A NAME="assign"></A><A NAME="ref36"></A><table width="100%"><tr bgcolor="#eeeeee"><td>String& &nbsp;<strong>assign</strong> (const char* value, int len = -1)
<br></td><td align="right"><h3><strong>assign</strong></h3></td></tr></table><p></p><p>
 Assigns a new value to the string from a character block.
</p>
<p><b>Parameters</b>:<TABLE BORDER="0" CELLPADDING="5">
<TR><TD align="left" valign="top"><i>value</i></TD><TD align="left" valign="top">New value of the string
</TD></TR>
<TR><TD align="left" valign="top"><i>len</i></TD><TD align="left" valign="top">Length of the data to copy, -1 for full string
</TD></TR>
</TABLE></P>
<p><b>Returns</b>: Reference to the String
     </p>
<A NAME="assign"></A><A NAME="ref37"></A><table width="100%"><tr bgcolor="#eeeeee"><td>String& &nbsp;<strong>assign</strong> (char value, unsigned int repeat = 1)
<br></td><td align="right"><h3><strong>assign</strong></h3></td></tr></table><p></p><p>
 Assigns a new value by filling with a repeated character
</p>
<p><b>Parameters</b>:<TABLE BORDER="0" CELLPADDING="5">
<TR><TD align="left" valign="top"><i>value</i></TD><TD align="left" valign="top">Character to fill the string
</TD></TR>
<TR><TD align="left" valign="top"><i>repeat</i></TD><TD align="left" valign="top">How many copies of the character to use
</TD></TR>
</TABLE></P>
<p><b>Returns</b>: Reference to the String
     </p>
<A NAME="hexify"></A><A NAME="ref38"></A><table width="100%"><tr bgcolor="#eeeeee"><td>String& &nbsp;<strong>hexify</strong> (void* data, unsigned int len, char sep = 0, bool upCase = false)
<br></td><td align="right"><h3><strong>hexify</strong></h3></td></tr></table><p></p><p>
 Build a hexadecimal representation of a buffer of data
</p>
<p><b>Parameters</b>:<TABLE BORDER="0" CELLPADDING="5">
<TR><TD align="left" valign="top"><i>data</i></TD><TD align="left" valign="top">Pointer to data to dump
</TD></TR>
<TR><TD align="left" valign="top"><i>len</i></TD><TD align="left" valign="top">Length of the data buffer
</TD></TR>
<TR><TD align="left" valign="top"><i>sep</i></TD><TD align="left" valign="top">Separator character to use between octets
</TD></TR>
<TR><TD align="left" valign="top"><i>upCase</i></TD><TD align="left" valign="top">Set to true to use upper case characters in hexa
</TD></TR>
</TABLE></P>
<p><b>Returns</b>: Reference to the String
     </p>
<A NAME="operator="></A><A NAME="ref39"></A><table width="100%"><tr bgcolor="#eeeeee"><td>inline String& &nbsp;<strong>operator=</strong> (const String& value)
<br></td><td align="right"><h3><strong>operator=</strong></h3></td></tr></table><p></p><p>
 Assignment operator.
     </p>
<A NAME="operator="></A><A NAME="ref40"></A><table width="100%"><tr bgcolor="#eeeeee"><td>inline String& &nbsp;<strong>operator=</strong> (const String* value)
<br></td><td align="right"><h3><strong>operator=</strong></h3></td></tr></table><p></p><p>
 Assignment from String* operator.
</p>
<p><b>See also</b>: <A HREF="TelEngine.html#strcpy">strcpy</A></p>
<A NAME="operator="></A><A NAME="ref41"></A><table width="100%"><tr bgcolor="#eeeeee"><td>String& &nbsp;<strong>operator=</strong> (const char* value)
<br></td><td align="right"><h3><strong>operator=</strong></h3></td></tr></table><p></p><p>
 Assignment from char* operator.
</p>
<p><b>See also</b>: <A HREF="TelEngine.html#strcpy">strcpy</A></p>
<A NAME="operator="></A><A NAME="ref42"></A><table width="100%"><tr bgcolor="#eeeeee"><td>String& &nbsp;<strong>operator=</strong> (char value)
<br></td><td align="right"><h3><strong>operator=</strong></h3></td></tr></table><p></p><p>
 Assignment operator for single characters.
     </p>
<A NAME="operator="></A><A NAME="ref43"></A><table width="100%"><tr bgcolor="#eeeeee"><td>String& &nbsp;<strong>operator=</strong> (int value)
<br></td><td align="right"><h3><strong>operator=</strong></h3></td></tr></table><p></p><p>
 Assignment operator for integers.
     </p>
<A NAME="operator="></A><A NAME="ref44"></A><table width="100%"><tr bgcolor="#eeeeee"><td>String& &nbsp;<strong>operator=</strong> (unsigned int value)
<br></td><td align="right"><h3><strong>operator=</strong></h3></td></tr></table><p></p><p>
 Assignment operator for unsigned integers.
     </p>
<A NAME="operator="></A><A NAME="ref45"></A><table width="100%"><tr bgcolor="#eeeeee"><td>inline String& &nbsp;<strong>operator=</strong> (bool value)
<br></td><td align="right"><h3><strong>operator=</strong></h3></td></tr></table><p></p><p>
 Assignment operator for booleans.
     </p>
<A NAME="operator+="></A><A NAME="ref46"></A><table width="100%"><tr bgcolor="#eeeeee"><td>String& &nbsp;<strong>operator+=</strong> (const char* value)
<br></td><td align="right"><h3><strong>operator+=</strong></h3></td></tr></table><p></p><p>
 Appending operator for strings.
</p>
<p><b>See also</b>: <A HREF="TelEngine.html#strcat">strcat</A></p>
<A NAME="operator+="></A><A NAME="ref47"></A><table width="100%"><tr bgcolor="#eeeeee"><td>String& &nbsp;<strong>operator+=</strong> (char value)
<br></td><td align="right"><h3><strong>operator+=</strong></h3></td></tr></table><p></p><p>
 Appending operator for single characters.
     </p>
<A NAME="operator+="></A><A NAME="ref48"></A><table width="100%"><tr bgcolor="#eeeeee"><td>String& &nbsp;<strong>operator+=</strong> (int value)
<br></td><td align="right"><h3><strong>operator+=</strong></h3></td></tr></table><p></p><p>
 Appending operator for integers.
     </p>
<A NAME="operator+="></A><A NAME="ref49"></A><table width="100%"><tr bgcolor="#eeeeee"><td>String& &nbsp;<strong>operator+=</strong> (unsigned int value)
<br></td><td align="right"><h3><strong>operator+=</strong></h3></td></tr></table><p></p><p>
 Appending operator for unsigned integers.
     </p>
<A NAME="operator+="></A><A NAME="ref50"></A><table width="100%"><tr bgcolor="#eeeeee"><td>inline String& &nbsp;<strong>operator+=</strong> (bool value)
<br></td><td align="right"><h3><strong>operator+=</strong></h3></td></tr></table><p></p><p>
 Appending operator for booleans.
     </p>
<A NAME="operator=="></A><A NAME="ref51"></A><table width="100%"><tr bgcolor="#eeeeee"><td>bool &nbsp;<strong>operator==</strong> (const char* value)
<br></td><td align="right"><h3><strong>operator==</strong></h3></td></tr></table><p> <small>[const]</small></p><p>
 Equality operator.
     </p>
<A NAME="operator!="></A><A NAME="ref52"></A><table width="100%"><tr bgcolor="#eeeeee"><td>bool &nbsp;<strong>operator!=</strong> (const char* value)
<br></td><td align="right"><h3><strong>operator!=</strong></h3></td></tr></table><p> <small>[const]</small></p><p>
 Inequality operator.
     </p>
<A NAME="operator=="></A><A NAME="ref53"></A><table width="100%"><tr bgcolor="#eeeeee"><td>bool &nbsp;<strong>operator==</strong> (const String& value)
<br></td><td align="right"><h3><strong>operator==</strong></h3></td></tr></table><p> <small>[const]</small></p><p>
 Fast equality operator.
     </p>
<A NAME="operator!="></A><A NAME="ref54"></A><table width="100%"><tr bgcolor="#eeeeee"><td>bool &nbsp;<strong>operator!=</strong> (const String& value)
<br></td><td align="right"><h3><strong>operator!=</strong></h3></td></tr></table><p> <small>[const]</small></p><p>
 Fast inequality operator.
     </p>
<A NAME="operator&="></A><A NAME="ref55"></A><table width="100%"><tr bgcolor="#eeeeee"><td>bool &nbsp;<strong>operator&=</strong> (const char* value)
<br></td><td align="right"><h3><strong>operator&=</strong></h3></td></tr></table><p> <small>[const]</small></p><p>
 Case-insensitive equality operator.
     </p>
<A NAME="operator|="></A><A NAME="ref56"></A><table width="100%"><tr bgcolor="#eeeeee"><td>bool &nbsp;<strong>operator|=</strong> (const char* value)
<br></td><td align="right"><h3><strong>operator|=</strong></h3></td></tr></table><p> <small>[const]</small></p><p>
 Case-insensitive inequality operator.
     </p>
<A NAME="operator%3C%3C"></A><A NAME="ref57"></A><table width="100%"><tr bgcolor="#eeeeee"><td>inline String& &nbsp;<strong>operator<<</strong> (const char* value)
<br></td><td align="right"><h3><strong>operator<<</strong></h3></td></tr></table><p></p><p>
 Stream style appending operator for C strings
     </p>
<A NAME="operator%3C%3C"></A><A NAME="ref58"></A><table width="100%"><tr bgcolor="#eeeeee"><td>inline String& &nbsp;<strong>operator<<</strong> (char value)
<br></td><td align="right"><h3><strong>operator<<</strong></h3></td></tr></table><p></p><p>
 Stream style appending operator for single characters
     </p>
<A NAME="operator%3C%3C"></A><A NAME="ref59"></A><table width="100%"><tr bgcolor="#eeeeee"><td>inline String& &nbsp;<strong>operator<<</strong> (int value)
<br></td><td align="right"><h3><strong>operator<<</strong></h3></td></tr></table><p></p><p>
 Stream style appending operator for integers
     </p>
<A NAME="operator%3C%3C"></A><A NAME="ref60"></A><table width="100%"><tr bgcolor="#eeeeee"><td>inline String& &nbsp;<strong>operator<<</strong> (unsigned int value)
<br></td><td align="right"><h3><strong>operator<<</strong></h3></td></tr></table><p></p><p>
 Stream style appending operator for unsigned integers
     </p>
<A NAME="operator%3C%3C"></A><A NAME="ref61"></A><table width="100%"><tr bgcolor="#eeeeee"><td>inline String& &nbsp;<strong>operator<<</strong> (bool value)
<br></td><td align="right"><h3><strong>operator<<</strong></h3></td></tr></table><p></p><p>
 Stream style appending operator for booleans
     </p>
<A NAME="operator%3E%3E"></A><A NAME="ref62"></A><table width="100%"><tr bgcolor="#eeeeee"><td>String& &nbsp;<strong>operator>></strong> (const char* skip)
<br></td><td align="right"><h3><strong>operator>></strong></h3></td></tr></table><p></p><p>
 Stream style substring skipping operator.
 It eats all characters up to and including the skip string
     </p>
<A NAME="operator%3E%3E"></A><A NAME="ref63"></A><table width="100%"><tr bgcolor="#eeeeee"><td>String& &nbsp;<strong>operator>></strong> (char& store)
<br></td><td align="right"><h3><strong>operator>></strong></h3></td></tr></table><p></p><p>
 Stream style extraction operator for single characters
     </p>
<A NAME="operator%3E%3E"></A><A NAME="ref64"></A><table width="100%"><tr bgcolor="#eeeeee"><td>String& &nbsp;<strong>operator>></strong> (int& store)
<br></td><td align="right"><h3><strong>operator>></strong></h3></td></tr></table><p></p><p>
 Stream style extraction operator for integers
     </p>
<A NAME="operator%3E%3E"></A><A NAME="ref65"></A><table width="100%"><tr bgcolor="#eeeeee"><td>String& &nbsp;<strong>operator>></strong> (unsigned int& store)
<br></td><td align="right"><h3><strong>operator>></strong></h3></td></tr></table><p></p><p>
 Stream style extraction operator for unsigned integers
     </p>
<A NAME="operator%3E%3E"></A><A NAME="ref66"></A><table width="100%"><tr bgcolor="#eeeeee"><td>String& &nbsp;<strong>operator>></strong> (bool& store)
<br></td><td align="right"><h3><strong>operator>></strong></h3></td></tr></table><p></p><p>
 Stream style extraction operator for booleans
     </p>
<A NAME="append"></A><A NAME="ref67"></A><table width="100%"><tr bgcolor="#eeeeee"><td>String& &nbsp;<strong>append</strong> (const char* value, const char* separator = 0, bool force = false)
<br></td><td align="right"><h3><strong>append</strong></h3></td></tr></table><p></p><p>
 Conditional appending with a separator
</p>
<p><b>Parameters</b>:<TABLE BORDER="0" CELLPADDING="5">
<TR><TD align="left" valign="top"><i>value</i></TD><TD align="left" valign="top">String to append
</TD></TR>
<TR><TD align="left" valign="top"><i>separator</i></TD><TD align="left" valign="top">Separator to insert before the value
</TD></TR>
<TR><TD align="left" valign="top"><i>force</i></TD><TD align="left" valign="top">True to allow appending empty strings
     </TD></TR>
</TABLE></P>
<A NAME="append"></A><A NAME="ref68"></A><table width="100%"><tr bgcolor="#eeeeee"><td>String& &nbsp;<strong>append</strong> (const ObjList* list, const char* separator = 0, bool force = false)
<br></td><td align="right"><h3><strong>append</strong></h3></td></tr></table><p></p><p>
 List members appending with a separator
</p>
<p><b>Parameters</b>:<TABLE BORDER="0" CELLPADDING="5">
<TR><TD align="left" valign="top"><i>list</i></TD><TD align="left" valign="top">Pointer to ObjList whose <A HREF="TelEngine__GenObject.html#toString">GenObject::toString</A>() of the items will be appended
</TD></TR>
<TR><TD align="left" valign="top"><i>separator</i></TD><TD align="left" valign="top">Separator to insert before each item in list
</TD></TR>
<TR><TD align="left" valign="top"><i>force</i></TD><TD align="left" valign="top">True to allow appending empty strings
     </TD></TR>
</TABLE></P>
<A NAME="append"></A><A NAME="ref69"></A><table width="100%"><tr bgcolor="#eeeeee"><td>inline String& &nbsp;<strong>append</strong> (const ObjList& list, const char* separator = 0, bool force = false)
<br></td><td align="right"><h3><strong>append</strong></h3></td></tr></table><p></p><p>
 List members appending with a separator
</p>
<p><b>Parameters</b>:<TABLE BORDER="0" CELLPADDING="5">
<TR><TD align="left" valign="top"><i>list</i></TD><TD align="left" valign="top">Reference of ObjList whose <A HREF="TelEngine__GenObject.html#toString">GenObject::toString</A>() of the items will be appended
</TD></TR>
<TR><TD align="left" valign="top"><i>separator</i></TD><TD align="left" valign="top">Separator to insert before each item in list
</TD></TR>
<TR><TD align="left" valign="top"><i>force</i></TD><TD align="left" valign="top">True to allow appending empty strings
     </TD></TR>
</TABLE></P>
<A NAME="append"></A><A NAME="ref70"></A><table width="100%"><tr bgcolor="#eeeeee"><td>String& &nbsp;<strong>append</strong> (double value, unsigned int decimals = 3)
<br></td><td align="right"><h3><strong>append</strong></h3></td></tr></table><p></p><p>
 Explicit double append
</p>
<p><b>Parameters</b>:<TABLE BORDER="0" CELLPADDING="5">
<TR><TD align="left" valign="top"><i>value</i></TD><TD align="left" valign="top">Value to append
</TD></TR>
<TR><TD align="left" valign="top"><i>decimals</i></TD><TD align="left" valign="top">Number of decimals
     </TD></TR>
</TABLE></P>
<A NAME="find"></A><A NAME="ref71"></A><table width="100%"><tr bgcolor="#eeeeee"><td>int &nbsp;<strong>find</strong> (char what, unsigned int offs = 0)
<br></td><td align="right"><h3><strong>find</strong></h3></td></tr></table><p> <small>[const]</small></p><p>
 Locate the first instance of a character in the string
</p>
<p><b>Parameters</b>:<TABLE BORDER="0" CELLPADDING="5">
<TR><TD align="left" valign="top"><i>what</i></TD><TD align="left" valign="top">Character to search for
</TD></TR>
<TR><TD align="left" valign="top"><i>offs</i></TD><TD align="left" valign="top">Offset in string to start searching from
</TD></TR>
</TABLE></P>
<p><b>Returns</b>: Offset of character or -1 if not found
     </p>
<A NAME="find"></A><A NAME="ref72"></A><table width="100%"><tr bgcolor="#eeeeee"><td>int &nbsp;<strong>find</strong> (const char* what, unsigned int offs = 0)
<br></td><td align="right"><h3><strong>find</strong></h3></td></tr></table><p> <small>[const]</small></p><p>
 Locate the first instance of a substring in the string
</p>
<p><b>Parameters</b>:<TABLE BORDER="0" CELLPADDING="5">
<TR><TD align="left" valign="top"><i>what</i></TD><TD align="left" valign="top">Substring to search for
</TD></TR>
<TR><TD align="left" valign="top"><i>offs</i></TD><TD align="left" valign="top">Offset in string to start searching from
</TD></TR>
</TABLE></P>
<p><b>Returns</b>: Offset of substring or -1 if not found
     </p>
<A NAME="rfind"></A><A NAME="ref73"></A><table width="100%"><tr bgcolor="#eeeeee"><td>int &nbsp;<strong>rfind</strong> (char what)
<br></td><td align="right"><h3><strong>rfind</strong></h3></td></tr></table><p> <small>[const]</small></p><p>
 Locate the last instance of a character in the string
</p>
<p><b>Parameters</b>:<TABLE BORDER="0" CELLPADDING="5">
<TR><TD align="left" valign="top"><i>what</i></TD><TD align="left" valign="top">Character to search for
</TD></TR>
</TABLE></P>
<p><b>Returns</b>: Offset of character or -1 if not found
     </p>
<A NAME="startsWith"></A><A NAME="ref74"></A><table width="100%"><tr bgcolor="#eeeeee"><td>bool &nbsp;<strong>startsWith</strong> (const char* what, bool wordBreak = false, bool caseInsensitive = false)
<br></td><td align="right"><h3><strong>startsWith</strong></h3></td></tr></table><p> <small>[const]</small></p><p>
 Checks if the string starts with a substring
</p>
<p><b>Parameters</b>:<TABLE BORDER="0" CELLPADDING="5">
<TR><TD align="left" valign="top"><i>what</i></TD><TD align="left" valign="top">Substring to search for
</TD></TR>
<TR><TD align="left" valign="top"><i>wordBreak</i></TD><TD align="left" valign="top">Check if a word boundary follows the substring
</TD></TR>
<TR><TD align="left" valign="top"><i>caseInsensitive</i></TD><TD align="left" valign="top">Compare case-insensitive if set
</TD></TR>
</TABLE></P>
<p><b>Returns</b>: True if the substring occurs at the beginning of the string
     </p>
<A NAME="endsWith"></A><A NAME="ref75"></A><table width="100%"><tr bgcolor="#eeeeee"><td>bool &nbsp;<strong>endsWith</strong> (const char* what, bool wordBreak = false, bool caseInsensitive = false)
<br></td><td align="right"><h3><strong>endsWith</strong></h3></td></tr></table><p> <small>[const]</small></p><p>
 Checks if the string ends with a substring
</p>
<p><b>Parameters</b>:<TABLE BORDER="0" CELLPADDING="5">
<TR><TD align="left" valign="top"><i>what</i></TD><TD align="left" valign="top">Substring to search for
</TD></TR>
<TR><TD align="left" valign="top"><i>wordBreak</i></TD><TD align="left" valign="top">Check if a word boundary precedes the substring
</TD></TR>
<TR><TD align="left" valign="top"><i>caseInsensitive</i></TD><TD align="left" valign="top">Compare case-insensitive if set
</TD></TR>
</TABLE></P>
<p><b>Returns</b>: True if the substring occurs at the end of the string
     </p>
<A NAME="startSkip"></A><A NAME="ref76"></A><table width="100%"><tr bgcolor="#eeeeee"><td>bool &nbsp;<strong>startSkip</strong> (const char* what, bool wordBreak = true, bool caseInsensitive = false)
<br></td><td align="right"><h3><strong>startSkip</strong></h3></td></tr></table><p></p><p>
 Checks if the string starts with a substring and removes it
</p>
<p><b>Parameters</b>:<TABLE BORDER="0" CELLPADDING="5">
<TR><TD align="left" valign="top"><i>what</i></TD><TD align="left" valign="top">Substring to search for
</TD></TR>
<TR><TD align="left" valign="top"><i>wordBreak</i></TD><TD align="left" valign="top">Check if a word boundary follows the substring;
  this parameter defaults to True because the intended use of this
  method is to separate commands from their parameters
</TD></TR>
<TR><TD align="left" valign="top"><i>caseInsensitive</i></TD><TD align="left" valign="top">Compare case-insensitive if set
</TD></TR>
</TABLE></P>
<p><b>Returns</b>: True if the substring occurs at the beginning of the string
  and also removes the substring; if wordBreak is True any word
  breaking characters are also removed
     </p>
<A NAME="matches"></A><A NAME="ref77"></A><table width="100%"><tr bgcolor="#eeeeee"><td> bool &nbsp;<strong>matches</strong> (const String& value)
<br></td><td align="right"><h3><strong>matches</strong></h3></td></tr></table><p> <small>[const virtual]</small></p><p>
 Checks if matches another string
</p>
<p><b>Parameters</b>:<TABLE BORDER="0" CELLPADDING="5">
<TR><TD align="left" valign="top"><i>value</i></TD><TD align="left" valign="top">String to check for match
</TD></TR>
</TABLE></P>
<p><b>Returns</b>: True if matches, false otherwise
     </p>
<A NAME="matches"></A><A NAME="ref78"></A><table width="100%"><tr bgcolor="#eeeeee"><td>bool &nbsp;<strong>matches</strong> (Regexp& rexp)
<br></td><td align="right"><h3><strong>matches</strong></h3></td></tr></table><p></p><p>
 Checks if matches a regular expression and fill the match substrings
</p>
<p><b>Parameters</b>:<TABLE BORDER="0" CELLPADDING="5">
<TR><TD align="left" valign="top"><i>rexp</i></TD><TD align="left" valign="top">Regular expression to check for match
</TD></TR>
</TABLE></P>
<p><b>Returns</b>: True if matches, false otherwise
     </p>
<A NAME="matchOffset"></A><A NAME="ref79"></A><table width="100%"><tr bgcolor="#eeeeee"><td>int &nbsp;<strong>matchOffset</strong> (int index = 0)
<br></td><td align="right"><h3><strong>matchOffset</strong></h3></td></tr></table><p> <small>[const]</small></p><p>
 Get the offset of the last match
</p>
<p><b>Parameters</b>:<TABLE BORDER="0" CELLPADDING="5">
<TR><TD align="left" valign="top"><i>index</i></TD><TD align="left" valign="top">Index of the submatch to return, 0 for full match
</TD></TR>
</TABLE></P>
<p><b>Returns</b>: Offset of the last match, -1 if no match or not in range
     </p>
<A NAME="matchLength"></A><A NAME="ref80"></A><table width="100%"><tr bgcolor="#eeeeee"><td>int &nbsp;<strong>matchLength</strong> (int index = 0)
<br></td><td align="right"><h3><strong>matchLength</strong></h3></td></tr></table><p> <small>[const]</small></p><p>
 Get the length of the last match
</p>
<p><b>Parameters</b>:<TABLE BORDER="0" CELLPADDING="5">
<TR><TD align="left" valign="top"><i>index</i></TD><TD align="left" valign="top">Index of the submatch to return, 0 for full match
</TD></TR>
</TABLE></P>
<p><b>Returns</b>: Length of the last match, 0 if no match or out of range
     </p>
<A NAME="matchString"></A><A NAME="ref81"></A><table width="100%"><tr bgcolor="#eeeeee"><td>inline String &nbsp;<strong>matchString</strong> (int index = 0)
<br></td><td align="right"><h3><strong>matchString</strong></h3></td></tr></table><p> <small>[const]</small></p><p>
 Get a copy of a matched (sub)string
</p>
<p><b>Parameters</b>:<TABLE BORDER="0" CELLPADDING="5">
<TR><TD align="left" valign="top"><i>index</i></TD><TD align="left" valign="top">Index of the submatch to return, 0 for full match
</TD></TR>
</TABLE></P>
<p><b>Returns</b>: Copy of the matched substring
     </p>
<A NAME="replaceMatches"></A><A NAME="ref82"></A><table width="100%"><tr bgcolor="#eeeeee"><td>String &nbsp;<strong>replaceMatches</strong> (const String& templ)
<br></td><td align="right"><h3><strong>replaceMatches</strong></h3></td></tr></table><p> <small>[const]</small></p><p>
 Create a string by replacing matched strings in a template
</p>
<p><b>Parameters</b>:<TABLE BORDER="0" CELLPADDING="5">
<TR><TD align="left" valign="top"><i>templ</i></TD><TD align="left" valign="top">Template of the string to generate
</TD></TR>
</TABLE></P>
<p><b>Returns</b>: Copy of template with "\0" - "\9" replaced with submatches
     </p>
<A NAME="matchCount"></A><A NAME="ref83"></A><table width="100%"><tr bgcolor="#eeeeee"><td>int &nbsp;<strong>matchCount</strong> ()
<br></td><td align="right"><h3><strong>matchCount</strong></h3></td></tr></table><p> <small>[const]</small></p><p>
 Get the total number of submatches from the last match, 0 if no match
</p>
<p><b>Returns</b>: Number of matching subexpressions
     </p>
<A NAME="split"></A><A NAME="ref84"></A><table width="100%"><tr bgcolor="#eeeeee"><td>ObjList* &nbsp;<strong>split</strong> (char separator, bool emptyOK = true)
<br></td><td align="right"><h3><strong>split</strong></h3></td></tr></table><p> <small>[const]</small></p><p>
 Splits the string at a delimiter character
</p>
<p><b>Parameters</b>:<TABLE BORDER="0" CELLPADDING="5">
<TR><TD align="left" valign="top"><i>separator</i></TD><TD align="left" valign="top">Character where to split the string
</TD></TR>
<TR><TD align="left" valign="top"><i>emptyOK</i></TD><TD align="left" valign="top">True if empty strings should be inserted in list
</TD></TR>
</TABLE></P>
<p><b>Returns</b>: A newly allocated list of strings, must be deleted after use
     </p>
<A NAME="msgEscape"></A><A NAME="ref85"></A><table width="100%"><tr bgcolor="#eeeeee"><td> String &nbsp;<strong>msgEscape</strong> (const char* str, char extraEsc = 0)
<br></td><td align="right"><h3><strong>msgEscape</strong></h3></td></tr></table><p> <small>[static]</small></p><p>
 Create an escaped string suitable for use in messages
</p>
<p><b>Parameters</b>:<TABLE BORDER="0" CELLPADDING="5">
<TR><TD align="left" valign="top"><i>str</i></TD><TD align="left" valign="top">String to convert to escaped format
</TD></TR>
<TR><TD align="left" valign="top"><i>extraEsc</i></TD><TD align="left" valign="top">Character to escape other than the default ones
</TD></TR>
</TABLE></P>
<p><b>Returns</b>: The string with special characters escaped
     </p>
<A NAME="msgEscape"></A><A NAME="ref86"></A><table width="100%"><tr bgcolor="#eeeeee"><td>inline String &nbsp;<strong>msgEscape</strong> (char extraEsc = 0)
<br></td><td align="right"><h3><strong>msgEscape</strong></h3></td></tr></table><p> <small>[const]</small></p><p>
 Create an escaped string suitable for use in messages
</p>
<p><b>Parameters</b>:<TABLE BORDER="0" CELLPADDING="5">
<TR><TD align="left" valign="top"><i>extraEsc</i></TD><TD align="left" valign="top">Character to escape other than the default ones
</TD></TR>
</TABLE></P>
<p><b>Returns</b>: The string with special characters escaped
     </p>
<A NAME="msgUnescape"></A><A NAME="ref87"></A><table width="100%"><tr bgcolor="#eeeeee"><td> String &nbsp;<strong>msgUnescape</strong> (const char* str, int* errptr = 0, char extraEsc = 0)
<br></td><td align="right"><h3><strong>msgUnescape</strong></h3></td></tr></table><p> <small>[static]</small></p><p>
 Decode an escaped string back to its raw form
</p>
<p><b>Parameters</b>:<TABLE BORDER="0" CELLPADDING="5">
<TR><TD align="left" valign="top"><i>str</i></TD><TD align="left" valign="top">String to convert to unescaped format
</TD></TR>
<TR><TD align="left" valign="top"><i>errptr</i></TD><TD align="left" valign="top">Pointer to an integer to receive the place of 1st error
</TD></TR>
<TR><TD align="left" valign="top"><i>extraEsc</i></TD><TD align="left" valign="top">Character to unescape other than the default ones
</TD></TR>
</TABLE></P>
<p><b>Returns</b>: The string with special characters unescaped
     </p>
<A NAME="msgUnescape"></A><A NAME="ref88"></A><table width="100%"><tr bgcolor="#eeeeee"><td>inline String &nbsp;<strong>msgUnescape</strong> (int* errptr = 0, char extraEsc = 0)
<br></td><td align="right"><h3><strong>msgUnescape</strong></h3></td></tr></table><p> <small>[const]</small></p><p>
 Decode an escaped string back to its raw form
</p>
<p><b>Parameters</b>:<TABLE BORDER="0" CELLPADDING="5">
<TR><TD align="left" valign="top"><i>errptr</i></TD><TD align="left" valign="top">Pointer to an integer to receive the place of 1st error
</TD></TR>
<TR><TD align="left" valign="top"><i>extraEsc</i></TD><TD align="left" valign="top">Character to unescape other than the default ones
</TD></TR>
</TABLE></P>
<p><b>Returns</b>: The string with special characters unescaped
     </p>
<A NAME="sqlEscape"></A><A NAME="ref89"></A><table width="100%"><tr bgcolor="#eeeeee"><td> String &nbsp;<strong>sqlEscape</strong> (const char* str, char extraEsc = 0)
<br></td><td align="right"><h3><strong>sqlEscape</strong></h3></td></tr></table><p> <small>[static]</small></p><p>
 Create an escaped string suitable for use in SQL queries
</p>
<p><b>Parameters</b>:<TABLE BORDER="0" CELLPADDING="5">
<TR><TD align="left" valign="top"><i>str</i></TD><TD align="left" valign="top">String to convert to escaped format
</TD></TR>
<TR><TD align="left" valign="top"><i>extraEsc</i></TD><TD align="left" valign="top">Character to escape other than the default ones
</TD></TR>
</TABLE></P>
<p><b>Returns</b>: The string with special characters escaped
     </p>
<A NAME="sqlEscape"></A><A NAME="ref90"></A><table width="100%"><tr bgcolor="#eeeeee"><td>inline String &nbsp;<strong>sqlEscape</strong> (char extraEsc = 0)
<br></td><td align="right"><h3><strong>sqlEscape</strong></h3></td></tr></table><p> <small>[const]</small></p><p>
 Create an escaped string suitable for use in SQL queries
</p>
<p><b>Parameters</b>:<TABLE BORDER="0" CELLPADDING="5">
<TR><TD align="left" valign="top"><i>extraEsc</i></TD><TD align="left" valign="top">Character to escape other than the default ones
</TD></TR>
</TABLE></P>
<p><b>Returns</b>: The string with special characters escaped
     </p>
<A NAME="uriEscape"></A><A NAME="ref91"></A><table width="100%"><tr bgcolor="#eeeeee"><td> String &nbsp;<strong>uriEscape</strong> (const char* str, char extraEsc = 0)
<br></td><td align="right"><h3><strong>uriEscape</strong></h3></td></tr></table><p> <small>[static]</small></p><p>
 Create an escaped string suitable for use in URIs
</p>
<p><b>Parameters</b>:<TABLE BORDER="0" CELLPADDING="5">
<TR><TD align="left" valign="top"><i>str</i></TD><TD align="left" valign="top">String to convert to escaped format
</TD></TR>
<TR><TD align="left" valign="top"><i>extraEsc</i></TD><TD align="left" valign="top">Character to escape other than the default ones
</TD></TR>
</TABLE></P>
<p><b>Returns</b>: The string with special characters escaped
     </p>
<A NAME="uriEscape"></A><A NAME="ref92"></A><table width="100%"><tr bgcolor="#eeeeee"><td>inline String &nbsp;<strong>uriEscape</strong> (char extraEsc = 0)
<br></td><td align="right"><h3><strong>uriEscape</strong></h3></td></tr></table><p> <small>[const]</small></p><p>
 Create an escaped string suitable for use in URI
</p>
<p><b>Parameters</b>:<TABLE BORDER="0" CELLPADDING="5">
<TR><TD align="left" valign="top"><i>extraEsc</i></TD><TD align="left" valign="top">Character to escape other than the default ones
</TD></TR>
</TABLE></P>
<p><b>Returns</b>: The string with special characters escaped
     </p>
<A NAME="uriUnescape"></A><A NAME="ref93"></A><table width="100%"><tr bgcolor="#eeeeee"><td> String &nbsp;<strong>uriUnescape</strong> (const char* str, int* errptr = 0)
<br></td><td align="right"><h3><strong>uriUnescape</strong></h3></td></tr></table><p> <small>[static]</small></p><p>
 Decode an URI escaped string back to its raw form
</p>
<p><b>Parameters</b>:<TABLE BORDER="0" CELLPADDING="5">
<TR><TD align="left" valign="top"><i>str</i></TD><TD align="left" valign="top">String to convert to unescaped format
</TD></TR>
<TR><TD align="left" valign="top"><i>errptr</i></TD><TD align="left" valign="top">Pointer to an integer to receive the place of 1st error
</TD></TR>
</TABLE></P>
<p><b>Returns</b>: The string with special characters unescaped
     </p>
<A NAME="uriUnescape"></A><A NAME="ref94"></A><table width="100%"><tr bgcolor="#eeeeee"><td>inline String &nbsp;<strong>uriUnescape</strong> (int* errptr = 0)
<br></td><td align="right"><h3><strong>uriUnescape</strong></h3></td></tr></table><p> <small>[const]</small></p><p>
 Decode an URI escaped string back to its raw form
</p>
<p><b>Parameters</b>:<TABLE BORDER="0" CELLPADDING="5">
<TR><TD align="left" valign="top"><i>errptr</i></TD><TD align="left" valign="top">Pointer to an integer to receive the place of 1st error
</TD></TR>
</TABLE></P>
<p><b>Returns</b>: The string with special characters unescaped
     </p>
<A NAME="changed"></A><A NAME="ref95"></A><table width="100%"><tr bgcolor="#eeeeee"><td> void &nbsp;<strong>changed</strong> ()
<br></td><td align="right"><h3><strong>changed</strong></h3></td></tr></table><p> <small>[protected virtual]</small></p><p>
 Called whenever the value changed (except in constructors).
     </p>
<HR>
	<table>
	<tr><td><small>Generated by: root on dragoshel on Mon Aug  4 10:38:21 2008, using kdoc 2.0a54.</small></td></tr>
	</table>
</BODY>
</HTML>
