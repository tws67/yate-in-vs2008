<HTML>
<HEAD>
<TITLE>class Engine</TITLE>

<META NAME="Generator" CONTENT="KDOC ">
</HEAD>
<BODY bgcolor="#ffffff" text="#000000" link="#0000ff" vlink="#000099" alink= "#ffffff">
<TABLE WIDTH="100%" BORDER="0">
<TR>
<TD>
	<TABLE BORDER="0">
		<TR><TD valign="top" align="left" cellspacing="10">
		<h1>class Engine</h1>
		</TD>
		<TD valign="top" align="right" colspan="1">Engine globals. <small><A HREF="#longdesc">More...</A></small></TD></TR>
	</TABLE>
	<HR>
	<TABLE BORDER="0">
		<TR><TH>Full name</TH><TD><code><A HREF="TelEngine.html">TelEngine</A>::Engine</code></TD></TR>
<TR><TH>Definition</TH><TD><code>#include &lt;<A HREF="yatengine_h.html">yatengine.h</A>&gt;</code></TD></TR>
<TR><TH><A HREF="full-list-TelEngine__Engine.html">List of all Methods</A></TH></TR>
	</TABLE>
	</TD>
<TD align="right"><TABLE BORDER="0"><TR><TD><small><A HREF="index-long.html">Annotated List</A></small></TD></TR>
<TR><TD><small><A HREF="header-list.html">Files</A></small></TD></TR>
<TR><TD><small><A HREF="all-globals.html">Globals</A></small></TD></TR>
<TR><TD><small><A HREF="hier.html">Hierarchy</A></small></TD></TR>
<TR><TD><small><A HREF="index.html">Index</A></small></TD></TR>
</TABLE></TD></TR></TABLE>
<h4>Public Types</h4><ul><LI>enum <A HREF="#ref3">RunMode</A> {	Stopped = 0,
	Console = 1,
	Client = 2,
	Server = 3,
    }
</LI>
<LI>enum <A HREF="#ref4">PluginMode</A> {	LoadFail = 0,
	LoadLate,
	LoadEarly
    }
</LI>
</ul><h4>Public Methods</h4><ul><LI>int &nbsp;<b><A HREF="#ref7">run</A></b> () 
</LI>
<LI>inline void &nbsp;<b><A HREF="#ref35">setHook</A></b> (MessagePostHook* hook, bool remove = false) 
</LI>
<LI>int &nbsp;<b><A HREF="#ref36">usedPlugins</A></b> () 
</LI>
<LI>inline unsigned int &nbsp;<b><A HREF="#ref37">messageCount</A></b> () 
</LI>
<LI>inline unsigned int &nbsp;<b><A HREF="#ref38">handlerCount</A></b> () 
</LI>
<LI>bool &nbsp;<b><A HREF="#ref39">loadPluginDir</A></b> (const String& relPath) 
</LI>
</ul><h4>Public Static Methods</h4><ul><LI>static  int &nbsp;<b><A HREF="#ref5">main</A></b> (int argc, const char** argv, const char** env,
	RunMode mode = Console, bool fail = false) 
</LI>
<LI>static  void &nbsp;<b><A HREF="#ref6">help</A></b> (bool client, bool errout = false) 
</LI>
<LI>static  Engine* &nbsp;<b><A HREF="#ref8">self</A></b> () 
</LI>
<LI>static  RunMode &nbsp;<b><A HREF="#ref9">mode</A></b> () 
</LI>
<LI>static inline  bool &nbsp;<b><A HREF="#ref10">clientMode</A></b> () 
</LI>
<LI>static  bool &nbsp;<b><A HREF="#ref11">Register</A></b> (const Plugin* plugin, bool reg = true) 
</LI>
<LI>static inline  const String& &nbsp;<b><A HREF="#ref12">nodeName</A></b> () 
</LI>
<LI>static inline  const String& &nbsp;<b><A HREF="#ref13">sharedPath</A></b> () 
</LI>
<LI>static  String &nbsp;<b><A HREF="#ref14">configFile</A></b> (const char* name, bool user = false) 
</LI>
<LI>static inline  const String& &nbsp;<b><A HREF="#ref15">configPath</A></b> () 
</LI>
<LI>static inline  const String& &nbsp;<b><A HREF="#ref16">configSuffix</A></b> () 
</LI>
<LI>static inline  const String& &nbsp;<b><A HREF="#ref17">modulePath</A></b> () 
</LI>
<LI>static  void &nbsp;<b><A HREF="#ref18">extraPath</A></b> (const String& path) 
</LI>
<LI>static inline  const String& &nbsp;<b><A HREF="#ref19">moduleSuffix</A></b> () 
</LI>
<LI>static  const char* &nbsp;<b><A HREF="#ref20">pathSeparator</A></b> () 
</LI>
<LI>static  const Configuration& &nbsp;<b><A HREF="#ref21">config</A></b> () 
</LI>
<LI>static  unsigned int &nbsp;<b><A HREF="#ref22">runId</A></b> () 
</LI>
<LI>static inline  const NamedList& &nbsp;<b><A HREF="#ref23">runParams</A></b> () 
</LI>
<LI>static  void &nbsp;<b><A HREF="#ref24">init</A></b> () 
</LI>
<LI>static  void &nbsp;<b><A HREF="#ref25">halt</A></b> (unsigned int code) 
</LI>
<LI>static  bool &nbsp;<b><A HREF="#ref26">restart</A></b> (unsigned int code, bool gracefull = false) 
</LI>
<LI>static  bool &nbsp;<b><A HREF="#ref27">exiting</A></b> () 
</LI>
<LI>static  bool &nbsp;<b><A HREF="#ref28">install</A></b> (MessageHandler* handler) 
</LI>
<LI>static  bool &nbsp;<b><A HREF="#ref29">uninstall</A></b> (MessageHandler* handler) 
</LI>
<LI>static  bool &nbsp;<b><A HREF="#ref30">enqueue</A></b> (Message* msg) 
</LI>
<LI>static inline  bool &nbsp;<b><A HREF="#ref31">enqueue</A></b> (const char* name) 
</LI>
<LI>static  bool &nbsp;<b><A HREF="#ref32">dispatch</A></b> (Message* msg) 
</LI>
<LI>static  bool &nbsp;<b><A HREF="#ref33">dispatch</A></b> (Message& msg) 
</LI>
<LI>static  bool &nbsp;<b><A HREF="#ref34">dispatch</A></b> (const char* name) 
</LI>
<LI>static  void &nbsp;<b><A HREF="#ref40">pluginMode</A></b> (PluginMode mode) 
</LI>
</ul><h4>Protected Methods</h4><ul><LI>&nbsp;<b><A HREF="#ref41">~Engine</A></b> () 
</LI>
<LI>bool &nbsp;<b><A HREF="#ref42">loadPlugin</A></b> (const char* file, bool local = false) 
</LI>
<LI>void &nbsp;<b><A HREF="#ref43">loadPlugins</A></b> () 
</LI>
<LI>void &nbsp;<b><A HREF="#ref44">initPlugins</A></b> () 
</LI>
</ul><HR><H2><A NAME="longdesc">Detailed Description</A></H2><p>
 This class holds global information about the engine.
 Note: this is a singleton class.
</p>
<p></p>
<A NAME="RunMode"></A><A NAME="ref3"></A><table width="100%"><tr bgcolor="#eeeeee"><td>enum <strong>RunMode</strong> {	Stopped = 0,
	Console = 1,
	Client = 2,
	Server = 3,
    }
</td><td align="right"><h3><strong>RunMode</strong></h3></td></tr></table><p></p><p>
 Running modes - run the engine as Console, Client or Server.
     </p>
<A NAME="PluginMode"></A><A NAME="ref4"></A><table width="100%"><tr bgcolor="#eeeeee"><td>enum <strong>PluginMode</strong> {	LoadFail = 0,
	LoadLate,
	LoadEarly
    }
</td><td align="right"><h3><strong>PluginMode</strong></h3></td></tr></table><p></p><p>
 Plugin load and initialization modes.
 Default is LoadLate that initailizes the plugin after others.
 LoadEarly will move the plugin to the front of the init order.
 LoadFail causes the plugin to be unloaded.
     </p>
<A NAME="main"></A><A NAME="ref5"></A><table width="100%"><tr bgcolor="#eeeeee"><td> int &nbsp;<strong>main</strong> (int argc, const char** argv, const char** env,
	RunMode mode = Console, bool fail = false)
<br></td><td align="right"><h3><strong>main</strong></h3></td></tr></table><p> <small>[static]</small></p><p>
 Main entry point to be called directly from a wrapper program
</p>
<p><b>Parameters</b>:<TABLE BORDER="0" CELLPADDING="5">
<TR><TD align="left" valign="top"><i>argc</i></TD><TD align="left" valign="top">Argument count
</TD></TR>
<TR><TD align="left" valign="top"><i>argv</i></TD><TD align="left" valign="top">Argument array
</TD></TR>
<TR><TD align="left" valign="top"><i>env</i></TD><TD align="left" valign="top">Environment variables
</TD></TR>
<TR><TD align="left" valign="top"><i>mode</i></TD><TD align="left" valign="top">Mode the engine must run as - Console, Client or Server
</TD></TR>
<TR><TD align="left" valign="top"><i>fail</i></TD><TD align="left" valign="top">Fail and return after parsing command line arguments
</TD></TR>
</TABLE></P>
<p><b>Returns</b>: Program exit code
     </p>
<A NAME="help"></A><A NAME="ref6"></A><table width="100%"><tr bgcolor="#eeeeee"><td> void &nbsp;<strong>help</strong> (bool client, bool errout = false)
<br></td><td align="right"><h3><strong>help</strong></h3></td></tr></table><p> <small>[static]</small></p><p>
 Display the help information on console
</p>
<p><b>Parameters</b>:<TABLE BORDER="0" CELLPADDING="5">
<TR><TD align="left" valign="top"><i>client</i></TD><TD align="left" valign="top">Display help for client running mode
</TD></TR>
<TR><TD align="left" valign="top"><i>errout</i></TD><TD align="left" valign="top">Display on stderr intead of stdout
     </TD></TR>
</TABLE></P>
<A NAME="run"></A><A NAME="ref7"></A><table width="100%"><tr bgcolor="#eeeeee"><td>int &nbsp;<strong>run</strong> ()
<br></td><td align="right"><h3><strong>run</strong></h3></td></tr></table><p></p><p>
 Run the engine.
</p>
<p><b>Returns</b>: Error code, 0 for success
     </p>
<A NAME="self"></A><A NAME="ref8"></A><table width="100%"><tr bgcolor="#eeeeee"><td> Engine* &nbsp;<strong>self</strong> ()
<br></td><td align="right"><h3><strong>self</strong></h3></td></tr></table><p> <small>[static]</small></p><p>
 Get a pointer to the unique instance.
</p>
<p><b>Returns</b>: A pointer to the singleton instance of the engine
     </p>
<A NAME="mode"></A><A NAME="ref9"></A><table width="100%"><tr bgcolor="#eeeeee"><td> RunMode &nbsp;<strong>mode</strong> ()
<br></td><td align="right"><h3><strong>mode</strong></h3></td></tr></table><p> <small>[static]</small></p><p>
 Get the running mode of the engine
</p>
<p><b>Returns</b>: Engine's run mode as enumerated value
     </p>
<A NAME="clientMode"></A><A NAME="ref10"></A><table width="100%"><tr bgcolor="#eeeeee"><td>inline  bool &nbsp;<strong>clientMode</strong> ()
<br></td><td align="right"><h3><strong>clientMode</strong></h3></td></tr></table><p> <small>[static]</small></p><p>
 Check if the engine is running as telephony client
</p>
<p><b>Returns</b>: True if the engine is running in client mode
     </p>
<A NAME="Register"></A><A NAME="ref11"></A><table width="100%"><tr bgcolor="#eeeeee"><td> bool &nbsp;<strong>Register</strong> (const Plugin* plugin, bool reg = true)
<br></td><td align="right"><h3><strong>Register</strong></h3></td></tr></table><p> <small>[static]</small></p><p>
 Register or unregister a plugin to the engine.
</p>
<p><b>Parameters</b>:<TABLE BORDER="0" CELLPADDING="5">
<TR><TD align="left" valign="top"><i>plugin</i></TD><TD align="left" valign="top">A pointer to the plugin to (un)register
</TD></TR>
<TR><TD align="left" valign="top"><i>reg</i></TD><TD align="left" valign="top">True to register (default), false to unregister
</TD></TR>
</TABLE></P>
<p><b>Returns</b>: True on success, false on failure
     </p>
<A NAME="nodeName"></A><A NAME="ref12"></A><table width="100%"><tr bgcolor="#eeeeee"><td>inline  const String& &nbsp;<strong>nodeName</strong> ()
<br></td><td align="right"><h3><strong>nodeName</strong></h3></td></tr></table><p> <small>[static]</small></p><p>
 Get the server node name, should be unique in a cluster
</p>
<p><b>Returns</b>: Node identifier string, defaults to host name
     </p>
<A NAME="sharedPath"></A><A NAME="ref13"></A><table width="100%"><tr bgcolor="#eeeeee"><td>inline  const String& &nbsp;<strong>sharedPath</strong> ()
<br></td><td align="right"><h3><strong>sharedPath</strong></h3></td></tr></table><p> <small>[static]</small></p><p>
 Get the application's shared directory path
</p>
<p><b>Returns</b>: The base path for shared files and directories
     </p>
<A NAME="configFile"></A><A NAME="ref14"></A><table width="100%"><tr bgcolor="#eeeeee"><td> String &nbsp;<strong>configFile</strong> (const char* name, bool user = false)
<br></td><td align="right"><h3><strong>configFile</strong></h3></td></tr></table><p> <small>[static]</small></p><p>
 Get the filename for a specific configuration
</p>
<p><b>Parameters</b>:<TABLE BORDER="0" CELLPADDING="5">
<TR><TD align="left" valign="top"><i>name</i></TD><TD align="left" valign="top">Name of the configuration requested
</TD></TR>
<TR><TD align="left" valign="top"><i>user</i></TD><TD align="left" valign="top">True to build a user settings path
</TD></TR>
</TABLE></P>
<p><b>Returns</b>: A full path configuration file name
     </p>
<A NAME="configPath"></A><A NAME="ref15"></A><table width="100%"><tr bgcolor="#eeeeee"><td>inline  const String& &nbsp;<strong>configPath</strong> ()
<br></td><td align="right"><h3><strong>configPath</strong></h3></td></tr></table><p> <small>[static]</small></p><p>
 Get the system configuration directory path
</p>
<p><b>Returns</b>: The directory path for system configuration files
     </p>
<A NAME="configSuffix"></A><A NAME="ref16"></A><table width="100%"><tr bgcolor="#eeeeee"><td>inline  const String& &nbsp;<strong>configSuffix</strong> ()
<br></td><td align="right"><h3><strong>configSuffix</strong></h3></td></tr></table><p> <small>[static]</small></p><p>
 Get the configuration file suffix
</p>
<p><b>Returns</b>: The suffix for configuration files
     </p>
<A NAME="modulePath"></A><A NAME="ref17"></A><table width="100%"><tr bgcolor="#eeeeee"><td>inline  const String& &nbsp;<strong>modulePath</strong> ()
<br></td><td align="right"><h3><strong>modulePath</strong></h3></td></tr></table><p> <small>[static]</small></p><p>
 The module loading path
     </p>
<A NAME="extraPath"></A><A NAME="ref18"></A><table width="100%"><tr bgcolor="#eeeeee"><td> void &nbsp;<strong>extraPath</strong> (const String& path)
<br></td><td align="right"><h3><strong>extraPath</strong></h3></td></tr></table><p> <small>[static]</small></p><p>
 Add a relative extra module loading path. The list is empty by default
  but can be filled by a main program before calling <A HREF="TelEngine__Engine.html#main">main</A>()
</p>
<p><b>Parameters</b>:<TABLE BORDER="0" CELLPADDING="5">
<TR><TD align="left" valign="top"><i>path</i></TD><TD align="left" valign="top">Relative path to extra modules to be loaded
     </TD></TR>
</TABLE></P>
<A NAME="moduleSuffix"></A><A NAME="ref19"></A><table width="100%"><tr bgcolor="#eeeeee"><td>inline  const String& &nbsp;<strong>moduleSuffix</strong> ()
<br></td><td align="right"><h3><strong>moduleSuffix</strong></h3></td></tr></table><p> <small>[static]</small></p><p>
 Get the module filename suffix
</p>
<p><b>Returns</b>: The suffix for module files
     </p>
<A NAME="pathSeparator"></A><A NAME="ref20"></A><table width="100%"><tr bgcolor="#eeeeee"><td> const char* &nbsp;<strong>pathSeparator</strong> ()
<br></td><td align="right"><h3><strong>pathSeparator</strong></h3></td></tr></table><p> <small>[static]</small></p><p>
 Get the canonical path element separator for the operating system
</p>
<p><b>Returns</b>: The operating system specific path element separator
     </p>
<A NAME="config"></A><A NAME="ref21"></A><table width="100%"><tr bgcolor="#eeeeee"><td> const Configuration& &nbsp;<strong>config</strong> ()
<br></td><td align="right"><h3><strong>config</strong></h3></td></tr></table><p> <small>[static]</small></p><p>
 The global configuration of the engine.
 You must use this resource with caution.
 Note that sections [general], [modules], [preload] and [postload] are
  reserved by the engine. Also [telephony] is reserved by the drivers.
</p>
<p><b>Returns</b>: A reference to the read-only engine configuration
     </p>
<A NAME="runId"></A><A NAME="ref22"></A><table width="100%"><tr bgcolor="#eeeeee"><td> unsigned int &nbsp;<strong>runId</strong> ()
<br></td><td align="right"><h3><strong>runId</strong></h3></td></tr></table><p> <small>[static]</small></p><p>
 Get a - supposedly unique - instance ID
</p>
<p><b>Returns</b>: Unique ID of the current running instance
     </p>
<A NAME="runParams"></A><A NAME="ref23"></A><table width="100%"><tr bgcolor="#eeeeee"><td>inline  const NamedList& &nbsp;<strong>runParams</strong> ()
<br></td><td align="right"><h3><strong>runParams</strong></h3></td></tr></table><p> <small>[static]</small></p><p>
 Get the engine parameters specific to this run.
</p>
<p><b>Returns</b>: A reference to the list of run specific parameters
     </p>
<A NAME="init"></A><A NAME="ref24"></A><table width="100%"><tr bgcolor="#eeeeee"><td> void &nbsp;<strong>init</strong> ()
<br></td><td align="right"><h3><strong>init</strong></h3></td></tr></table><p> <small>[static]</small></p><p>
 Reinitialize the plugins
     </p>
<A NAME="halt"></A><A NAME="ref25"></A><table width="100%"><tr bgcolor="#eeeeee"><td> void &nbsp;<strong>halt</strong> (unsigned int code)
<br></td><td align="right"><h3><strong>halt</strong></h3></td></tr></table><p> <small>[static]</small></p><p>
 Stop the engine and the entire program
</p>
<p><b>Parameters</b>:<TABLE BORDER="0" CELLPADDING="5">
<TR><TD align="left" valign="top"><i>code</i></TD><TD align="left" valign="top">Return code of the program
     </TD></TR>
</TABLE></P>
<A NAME="restart"></A><A NAME="ref26"></A><table width="100%"><tr bgcolor="#eeeeee"><td> bool &nbsp;<strong>restart</strong> (unsigned int code, bool gracefull = false)
<br></td><td align="right"><h3><strong>restart</strong></h3></td></tr></table><p> <small>[static]</small></p><p>
 Stop and restart the engine and the entire program
</p>
<p><b>Parameters</b>:<TABLE BORDER="0" CELLPADDING="5">
<TR><TD align="left" valign="top"><i>code</i></TD><TD align="left" valign="top">Return code of the program
</TD></TR>
<TR><TD align="left" valign="top"><i>gracefull</i></TD><TD align="left" valign="top">Attempt to wait until no plugin is busy
</TD></TR>
</TABLE></P>
<p><b>Returns</b>: True if restart was initiated, false if exiting or no supervisor
     </p>
<A NAME="exiting"></A><A NAME="ref27"></A><table width="100%"><tr bgcolor="#eeeeee"><td> bool &nbsp;<strong>exiting</strong> ()
<br></td><td align="right"><h3><strong>exiting</strong></h3></td></tr></table><p> <small>[static]</small></p><p>
 Check if the engine is currently exiting
</p>
<p><b>Returns</b>: True if exiting, false in normal operation
     </p>
<A NAME="install"></A><A NAME="ref28"></A><table width="100%"><tr bgcolor="#eeeeee"><td> bool &nbsp;<strong>install</strong> (MessageHandler* handler)
<br></td><td align="right"><h3><strong>install</strong></h3></td></tr></table><p> <small>[static]</small></p><p>
 Installs a handler in the dispatcher.
</p>
<p><b>Parameters</b>:<TABLE BORDER="0" CELLPADDING="5">
<TR><TD align="left" valign="top"><i>handler</i></TD><TD align="left" valign="top">A pointer to the handler to install
</TD></TR>
</TABLE></P>
<p><b>Returns</b>: True on success, false on failure
     </p>
<A NAME="uninstall"></A><A NAME="ref29"></A><table width="100%"><tr bgcolor="#eeeeee"><td> bool &nbsp;<strong>uninstall</strong> (MessageHandler* handler)
<br></td><td align="right"><h3><strong>uninstall</strong></h3></td></tr></table><p> <small>[static]</small></p><p>
 Uninstalls a handler drom the dispatcher.
</p>
<p><b>Parameters</b>:<TABLE BORDER="0" CELLPADDING="5">
<TR><TD align="left" valign="top"><i>handler</i></TD><TD align="left" valign="top">A pointer to the handler to uninstall
</TD></TR>
</TABLE></P>
<p><b>Returns</b>: True on success, false on failure
     </p>
<A NAME="enqueue"></A><A NAME="ref30"></A><table width="100%"><tr bgcolor="#eeeeee"><td> bool &nbsp;<strong>enqueue</strong> (Message* msg)
<br></td><td align="right"><h3><strong>enqueue</strong></h3></td></tr></table><p> <small>[static]</small></p><p>
 Enqueue a message in the message queue for asynchronous dispatching
</p>
<p><b>Parameters</b>:<TABLE BORDER="0" CELLPADDING="5">
<TR><TD align="left" valign="top"><i>msg</i></TD><TD align="left" valign="top">The message to enqueue, will be destroyed after dispatching
</TD></TR>
</TABLE></P>
<p><b>Returns</b>: True if enqueued, false on error (already queued)
     </p>
<A NAME="enqueue"></A><A NAME="ref31"></A><table width="100%"><tr bgcolor="#eeeeee"><td>inline  bool &nbsp;<strong>enqueue</strong> (const char* name)
<br></td><td align="right"><h3><strong>enqueue</strong></h3></td></tr></table><p> <small>[static]</small></p><p>
 Convenience function.
 Enqueue a new parameterless message in the message queue
</p>
<p><b>Parameters</b>:<TABLE BORDER="0" CELLPADDING="5">
<TR><TD align="left" valign="top"><i>name</i></TD><TD align="left" valign="top">Name of the parameterless message to put in queue
</TD></TR>
</TABLE></P>
<p><b>Returns</b>: True if enqueued, false on error (already queued)
     </p>
<A NAME="dispatch"></A><A NAME="ref32"></A><table width="100%"><tr bgcolor="#eeeeee"><td> bool &nbsp;<strong>dispatch</strong> (Message* msg)
<br></td><td align="right"><h3><strong>dispatch</strong></h3></td></tr></table><p> <small>[static]</small></p><p>
 Synchronously dispatch a message to the registered handlers
</p>
<p><b>Parameters</b>:<TABLE BORDER="0" CELLPADDING="5">
<TR><TD align="left" valign="top"><i>msg</i></TD><TD align="left" valign="top">Pointer to the message to dispatch
</TD></TR>
</TABLE></P>
<p><b>Returns</b>: True if one handler accepted it, false if all ignored
     </p>
<A NAME="dispatch"></A><A NAME="ref33"></A><table width="100%"><tr bgcolor="#eeeeee"><td> bool &nbsp;<strong>dispatch</strong> (Message& msg)
<br></td><td align="right"><h3><strong>dispatch</strong></h3></td></tr></table><p> <small>[static]</small></p><p>
 Synchronously dispatch a message to the registered handlers
</p>
<p><b>Parameters</b>:<TABLE BORDER="0" CELLPADDING="5">
<TR><TD align="left" valign="top"><i>msg</i></TD><TD align="left" valign="top">The message to dispatch
</TD></TR>
</TABLE></P>
<p><b>Returns</b>: True if one handler accepted it, false if all ignored
     </p>
<A NAME="dispatch"></A><A NAME="ref34"></A><table width="100%"><tr bgcolor="#eeeeee"><td> bool &nbsp;<strong>dispatch</strong> (const char* name)
<br></td><td align="right"><h3><strong>dispatch</strong></h3></td></tr></table><p> <small>[static]</small></p><p>
 Convenience function.
 Dispatch a parameterless message to the registered handlers
</p>
<p><b>Parameters</b>:<TABLE BORDER="0" CELLPADDING="5">
<TR><TD align="left" valign="top"><i>name</i></TD><TD align="left" valign="top">The name of the message to create and dispatch
</TD></TR>
</TABLE></P>
<p><b>Returns</b>: True if one handler accepted it, false if all ignored
     </p>
<A NAME="setHook"></A><A NAME="ref35"></A><table width="100%"><tr bgcolor="#eeeeee"><td>inline void &nbsp;<strong>setHook</strong> (MessagePostHook* hook, bool remove = false)
<br></td><td align="right"><h3><strong>setHook</strong></h3></td></tr></table><p></p><p>
 Install or remove a hook to catch messages after being dispatched
</p>
<p><b>Parameters</b>:<TABLE BORDER="0" CELLPADDING="5">
<TR><TD align="left" valign="top"><i>hook</i></TD><TD align="left" valign="top">Pointer to a post-dispatching message hook
</TD></TR>
<TR><TD align="left" valign="top"><i>remove</i></TD><TD align="left" valign="top">Set to True to remove the hook instead of adding
     </TD></TR>
</TABLE></P>
<A NAME="usedPlugins"></A><A NAME="ref36"></A><table width="100%"><tr bgcolor="#eeeeee"><td>int &nbsp;<strong>usedPlugins</strong> ()
<br></td><td align="right"><h3><strong>usedPlugins</strong></h3></td></tr></table><p></p><p>
 Get a count of plugins that are actively in use
</p>
<p><b>Returns</b>: Count of plugins in use
     </p>
<A NAME="messageCount"></A><A NAME="ref37"></A><table width="100%"><tr bgcolor="#eeeeee"><td>inline unsigned int &nbsp;<strong>messageCount</strong> ()
<br></td><td align="right"><h3><strong>messageCount</strong></h3></td></tr></table><p></p><p>
 Get the number of messages waiting in the queue
</p>
<p><b>Returns</b>: Count of messages in the queue
     </p>
<A NAME="handlerCount"></A><A NAME="ref38"></A><table width="100%"><tr bgcolor="#eeeeee"><td>inline unsigned int &nbsp;<strong>handlerCount</strong> ()
<br></td><td align="right"><h3><strong>handlerCount</strong></h3></td></tr></table><p></p><p>
 Get the number of handlers in the dispatcher
</p>
<p><b>Returns</b>: Count of handlers
     </p>
<A NAME="loadPluginDir"></A><A NAME="ref39"></A><table width="100%"><tr bgcolor="#eeeeee"><td>bool &nbsp;<strong>loadPluginDir</strong> (const String& relPath)
<br></td><td align="right"><h3><strong>loadPluginDir</strong></h3></td></tr></table><p></p><p>
 Loads the plugins from an extra plugins directory
</p>
<p><b>Parameters</b>:<TABLE BORDER="0" CELLPADDING="5">
<TR><TD align="left" valign="top"><i>relPath</i></TD><TD align="left" valign="top">Path to the extra directory, relative to the main modules
</TD></TR>
</TABLE></P>
<p><b>Returns</b>: True if the directory could at least be opened
     </p>
<A NAME="pluginMode"></A><A NAME="ref40"></A><table width="100%"><tr bgcolor="#eeeeee"><td> void &nbsp;<strong>pluginMode</strong> (PluginMode mode)
<br></td><td align="right"><h3><strong>pluginMode</strong></h3></td></tr></table><p> <small>[static]</small></p><p>
 Set the load and init mode of the currently loading <A HREF="TelEngine__Plugin.html">Plugin</A>
</p>
<p><b>Parameters</b>:<TABLE BORDER="0" CELLPADDING="5">
<TR><TD align="left" valign="top"><i>mode</i></TD><TD align="left" valign="top">Load and init mode, default LoadLate
     </TD></TR>
</TABLE></P>
<A NAME="~Engine"></A><A NAME="ref41"></A><table width="100%"><tr bgcolor="#eeeeee"><td>&nbsp;<strong>~Engine</strong> ()
<br></td><td align="right"><h3><strong>~Engine</strong></h3></td></tr></table><p> <small>[protected]</small></p><p>
 Destroys the engine and everything. You must not call it directly,
 <A HREF="TelEngine__Engine.html#run">run</A>() will do it for you.
     </p>
<A NAME="loadPlugin"></A><A NAME="ref42"></A><table width="100%"><tr bgcolor="#eeeeee"><td>bool &nbsp;<strong>loadPlugin</strong> (const char* file, bool local = false)
<br></td><td align="right"><h3><strong>loadPlugin</strong></h3></td></tr></table><p> <small>[protected]</small></p><p>
 Loads one plugin from a shared object file
</p>
<p><b>Parameters</b>:<TABLE BORDER="0" CELLPADDING="5">
<TR><TD align="left" valign="top"><i>file</i></TD><TD align="left" valign="top">Name of the plugin file to load
</TD></TR>
<TR><TD align="left" valign="top"><i>local</i></TD><TD align="left" valign="top">Attempt to keep symbols local if supported by the system
</TD></TR>
</TABLE></P>
<p><b>Returns</b>: True if success, false on failure
     </p>
<A NAME="loadPlugins"></A><A NAME="ref43"></A><table width="100%"><tr bgcolor="#eeeeee"><td>void &nbsp;<strong>loadPlugins</strong> ()
<br></td><td align="right"><h3><strong>loadPlugins</strong></h3></td></tr></table><p> <small>[protected]</small></p><p>
 Loads the plugins from the plugins directory
     </p>
<A NAME="initPlugins"></A><A NAME="ref44"></A><table width="100%"><tr bgcolor="#eeeeee"><td>void &nbsp;<strong>initPlugins</strong> ()
<br></td><td align="right"><h3><strong>initPlugins</strong></h3></td></tr></table><p> <small>[protected]</small></p><p>
 Initialize all registered plugins
     </p>
<HR>
	<table>
	<tr><td><small>Generated by: root on dragoshel on Mon Aug  4 10:38:21 2008, using kdoc 2.0a54.</small></td></tr>
	</table>
</BODY>
</HTML>
